I/O模型可以按照同步或异步分成以下几类：

![Snipaste_2020-10-28_20-38-50199927f8e49d1700.png](https://picbed.familyds.com:8891/2020/10/28/Snipaste_2020-10-28_20-38-50199927f8e49d1700.png)

# 同步I/O

## BIO

BIO(Blocking IO，阻塞IO)，在服务端每当主线程accept一个请求后，发起IO请求并一直`阻塞IO`，直到缓冲区数据就绪之后才进行下一步操作

也可以`每次`主线程accept一个请求之后，创建`新的线程`进行recv，但这样会产生大量的线程，极度消耗系统资源

## NIO

NIO(Non-Blocking IO，非阻塞IO)，主线程accept请求之后，`立即返回`，然后将当前的已连接描述符加入描述符集合，之后要`轮询`描述符集合（包括没有读写事件的fd）来检查IO缓冲区数据是否就绪

## IO多路复用

IO多路复用使得一个线程可以监视多个描述符，一旦有一个描述符就绪，就可以进行处理

`单线程`，通过调用系统级的select、poll或epoll函数来获取fd列表，并只遍历`有事件的fd`

### select

select支持几乎所有平台，使用`bitmap`作为数据结构

单个进程能够打开的fd`数量是有限制的`，默认1024

每次调用select都需要将fd集合`从用户态拷贝到内核态`，开销较大

依然需要`轮询`fd，效率较低

### poll

使用`数组`作为数据结构

相比于select，仅仅减少了数量限制

### epoll

epoll只能用在Linux中，使用`红黑树`作为数据结构

只需要在开始的时候`复制一次`文件描述符列表

epoll不轮询描述符，而是通过每个`就绪`的描述符`回调`相邻的描述符

epoll有两种操作模式：LT（Level Trigger）和ET（Edge Trigger）

- LT：epoll_wait检测到描述符事件并通知应用程序后，应用程序可以`不立即处理`，在下次效用epoll_wait时，还会`再次响应`应用程序并通知该事件

- ET：检测到事件后，应用程序`必须立即`处理事件，下次调用epoll_wait时，`不会再次`通知此事件

相比于LT，`ET的效率更高`，因为它减少了事件被重复触发的次数，不过使用ET模式的时候，必须使用`非阻塞socket`，以免多个文件描述符的处理被某一个阻塞操作饿死

epoll在redis和nginx中应用广泛

# 异步I/O

## AIO

AIO（Asynchronous IO，异步IO），它不需要像NIO那样轮询所有IO的状态，而是在IO准备就绪之后，`系统会通知`线程来进行处理
