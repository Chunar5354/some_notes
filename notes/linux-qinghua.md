* [操作系统的启动](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8)
* [操作系统与设备和程序交互](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%BE%E5%A4%87%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BA%A4%E4%BA%92)
  * [概念](#%E6%A6%82%E5%BF%B5)
  * [区别](#%E5%8C%BA%E5%88%AB)
  * [中断处理](#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86)
  * [异常处理](#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
  * [系统调用处理](#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86)
* [连续内存管理](#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)
  * [内存分层体系](#%E5%86%85%E5%AD%98%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB)
  * [操作系统对内存的管理](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E7%AE%A1%E7%90%86)
  * [地址空间](#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)
  * [内存分配](#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D)
  * [碎片整理](#%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86)
* [非连续内存管理](#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)
  * [分段](#%E5%88%86%E6%AE%B5)
  * [分页](#%E5%88%86%E9%A1%B5)
  * [页表](#%E9%A1%B5%E8%A1%A8)
    * [反向页表](#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8)
* [虚拟内存](#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
  * [覆盖技术](#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF)
  * [交换技术](#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF)
  * [虚拟技术](#%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF)
    * [虚拟技术流程](#%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E6%B5%81%E7%A8%8B)
    * [虚拟技术基本特征](#%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81)
    * [虚拟页式内存管理](#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)
    * [后备存储](#%E5%90%8E%E5%A4%87%E5%AD%98%E5%82%A8)
  * [局部页面置换算法](#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
    * [1\.最优页面置换算法](#1%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
    * [2\.先进先出算法](#2%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95)
    * [3\.最近最久未使用 LRU](#3%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8-lru)
    * [4\.时钟页面置换算法 Clock](#4%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-clock)
    * [5\.二次机会法](#5%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95)
    * [6\.最不常用法 LFU](#6%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%B3%95-lfu)
    * [Belady现象](#belady%E7%8E%B0%E8%B1%A1)
  * [全局页面置换算法](#%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
    * [工作集模型](#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B)
    * [工作集替换算法](#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95)
    * [缺页率页面置换算法](#%E7%BC%BA%E9%A1%B5%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
    * [抖动问题](#%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98)
* [进程](#%E8%BF%9B%E7%A8%8B)
  * [进程控制结构](#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84)
  * [进程的状态管理](#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86)
    * [进程的生命周期](#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
    * [进程状态变化模型](#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%9E%8B)
    * [进程挂起](#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7)
    * [状态管理](#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86)
  * [线程](#%E7%BA%BF%E7%A8%8B)
    * [进程与线程比较](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BE%83)
    * [线程的实现](#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0)
  * [上下文切换](#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2)
  * [进程控制](#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6)
    * [进程创建](#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA)
    * [进程加载和执行](#%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C)
    * [进程等待](#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85)
    * [进程终止](#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2)
* [调度](#%E8%B0%83%E5%BA%A6)
  * [评价调度算法的指标](#%E8%AF%84%E4%BB%B7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%8C%87%E6%A0%87)
  * [调度算法](#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
    * [FCFS 先来先服务](#fcfs-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1)
    * [SPN 短进程优先](#spn-%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88)
    * [HRRN 最高响应比优先](#hrrn-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88)
    * [Round Cobin 轮询](#round-cobin-%E8%BD%AE%E8%AF%A2)
    * [Mutilevel Feedback Queues 多级反馈队列](#mutilevel-feedback-queues-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97)
    * [Fair Share Scheduling 公平共享调度](#fair-share-scheduling-%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6)
  * [实时调度](#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6)
  * [多处理器调度](#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6)
  * [优先级反转](#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC)
* [同步](#%E5%90%8C%E6%AD%A5)
  * [临界区](#%E4%B8%B4%E7%95%8C%E5%8C%BA)
  * [1\.禁用硬件中断](#1%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD)
  * [2\.软件方法](#2%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95)
  * [3\.高级抽象](#3%E9%AB%98%E7%BA%A7%E6%8A%BD%E8%B1%A1)
    * [原子指令](#%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4)
    * [test\-and\-set 实现锁](#test-and-set-%E5%AE%9E%E7%8E%B0%E9%94%81)
    * [exchange 实现锁](#exchange-%E5%AE%9E%E7%8E%B0%E9%94%81)
* [信号量](#%E4%BF%A1%E5%8F%B7%E9%87%8F)
  * [信号量的使用](#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8)
    * [用信号量实现锁](#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E9%94%81)
    * [用信号量实现调度约束](#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%B0%83%E5%BA%A6%E7%BA%A6%E6%9D%9F)
  * [信号量的实现](#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0)
  * [管程 monitor](#%E7%AE%A1%E7%A8%8B-monitor)
  * [读写者问题](#%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98)
  * [哲学家就餐问题](#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)
* [死锁](#%E6%AD%BB%E9%94%81)
  * [死锁的特征](#%E6%AD%BB%E9%94%81%E7%9A%84%E7%89%B9%E5%BE%81)
  * [死锁的处理](#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86)
    * [死锁的预防](#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2)
    * [死锁的避免](#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D)
    * [死锁检测](#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B)
  * [进程间通信 IPC](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-ipc)
    * [直接通信](#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1)
    * [间接通信](#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1)
    * [信号](#%E4%BF%A1%E5%8F%B7)
    * [管道](#%E7%AE%A1%E9%81%93)
    * [消息队列](#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
    * [共享内存](#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)
* [文件系统](#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
  * [文件描述符](#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)
  * [文件访问](#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE)
  * [目录](#%E7%9B%AE%E5%BD%95)
  * [文件别名](#%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D)
  * [文件系统种类](#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB)
  * [虚拟文件系统](#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
  * [数据块缓存](#%E6%95%B0%E6%8D%AE%E5%9D%97%E7%BC%93%E5%AD%98)
  * [打开文件](#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6)
  * [为文件分配数据块](#%E4%B8%BA%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE%E5%9D%97)
  * [空闲数据块](#%E7%A9%BA%E9%97%B2%E6%95%B0%E6%8D%AE%E5%9D%97)
  * [多磁盘管理 RAID](#%E5%A4%9A%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-raid)
  * [磁盘调度](#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6)


操作系统将硬件设备映射成为软件概念：

- CPU: 进程

- 内存：地址空间

- 硬盘：文件系统

操作系统实现的是承上启下的作用，分为shell（壳）与kernel（内核）

内核主要的系统组件包括：

- CPU调度器

- 物理内存管理

- 虚拟内存管理

- 文件系统管理

- 中断处理与设备驱动

内核的主要特征：

- 并发

- 共享

- 虚拟

- 异步

## 操作系统的启动

操作系统存放在disk上，开机时启动BIOS（基本IO处理系统，让系统检测外设）

disk上还有Bootloader，用来加载OS

BIOS存在内存中，它从固定的起始地址（`CS:IP=0xf000:fff0`）开始执行

- 1.首先加电自检

- 2.寻找显卡和执行BIOS

- 3.BIOS将硬盘上的Bootloader加载到内存中

将Bootloader从磁盘的引导扇区（一般是第一个扇区）加载到内存的0x7c00

- 4.Bootloader将OS的代码和数据从磁盘加载到内存中，并跳转到OS的起始地址

## 操作系统与设备和程序交互

与设备：通过中断与IO

与程序：系统调用与异常

### 概念

系统调用（system call）：应用程序主动向操作系统发出服务请求

异常：非法指令或错误的处理状态

中断：来自硬件设备的计时器或网络中断

### 区别

- 源头

中断：外设

异常：应用程序意想不到的行为

系统调用：应用程序发起

- 执行时间

中断：异步

异常：同步

系统调用：同步或异步

- 响应

中断：持续，对应用程序透明

异常：杀死或重新执行产生异常的指令

系统调用：等待和持续

### 中断处理

外设设置`中断标记`，告诉CPU产生了中断，CPU根据中断标记产生`中断号`，告知操作系统

操作系统首先保存`当前的处理状态`，根据中断号查找相应的中断服务，处理之后`清除中断标记`，然后恢复之前保存的处理状态

### 异常处理

CPU产生异常编号，告知操作系统

操作系统首先保存现场，执行异常处理（杀死程序或重新执行程序），然后恢复现场

### 系统调用处理

操作系统向应用程序提供的`接口`，用于实现内核服务

应用程序通过高级API来进行系统调用（而不是直接发起系统调用）

Windows通过`Win32 API`

Unix, Linux和Mac OS通过`POSIX API`

应用程序发起系统调用会触发`用户态`到`内核态`的转变，需要切换堆栈，开销要比普通的函数调用更大

系统调用开销：

- 建立中断、异常、系统调用序号与对应服务程序`映射关系`（表）的初始化开销

- 建立内核`堆栈`

- 验证参数（因为用户程序不可信）

- 数据在内核态与用户态之间互相`拷贝`的开销

- 内核由独立的地址空间，切换时`TLB`（页表）可能会刷新

## 连续内存管理

### 内存分层体系

计算机的存储是分层体系，从上到下速度逐渐减小，容量逐渐增大

- CPU寄存器

- CPU缓存：L1, L2, L3

- 主存

- 硬盘

### 操作系统对内存的管理

操作系统对内存主要进行以下管理：

- 抽象：逻辑地址空间

- 保护：独立地址空间

- 共享：不同进程访问同一块内存

- 虚拟：获得更多地址空间

通过MMU来完成物理地址空间与逻辑（虚拟）地址空间的转换

### 地址空间

- 物理地址空间：硬件支持的地址空间

- 逻辑地址空间：一个运行的程序所拥有的内存范围

用户编写的应用程序通过`编译`、`链接`、`加载`最后得到的地址是`逻辑地址`

CPU中的硬件`MMU`（内存管理单元）中存储了逻辑地址到物理地址的`映射`

CPU要执行指令时，通过MMU根据逻辑地址查找`物理地址`

- 如果找到，就直接去物理地址找到指令

- 如果没找到，就到`主存`中去找

### 内存分配

- 内存碎片：`外碎片`（分配单元间的未使用内存），`内碎片`（分配单元内的未使用内存）

内存分配策略：

- 首次适配

为了分配n字节，使用`第一个`比n大的可用空闲块

优点是`简单`，并且容易合并成一个`更大的空闲块`

缺点是容易产生`外碎片`

- 最优适配

为了分配n字节，使用`最小`的可用空闲块

优点是对于大部分分配是小尺寸时非常有效

缺点是容易产生外碎片，且会产生很多用不到的`微小碎片`，`重分配慢`

- 最差分配

为了分配n字节，使用`最大`的可用空闲块

- 优点是中等尺寸分配时效果最好

- 缺点是产生外部碎片，将大空闲块拆分导致需要大内存的请求无法被分配，重分配慢

### 碎片整理

- 压缩式

程序所使用的内存可`动态调整`，将所有正在被占用的地址空间移动到一起，将外碎片聚合成更大的可用空间

- 交换式

当某程序需要更多的内存时，就`抢占等待中的程序`，腾出内存空间

将被抢占的程序swap到`硬盘`上

## 非连续内存管理

非连续内存可以减少碎片，并允许`共享`和`动态链接`

由于维护虚拟地址和物理地址的转换开销较大，所以用`硬件`来实现

两种管理机制：分段和分页

### 分段

每个程序包括堆段、栈段、程序数据段等多个段，可以`将不同的段分散`到多个物理地址空间

段访问机制需要`段号`+`段内偏移`

`段表`储存段号逻辑地址与物理地址的`映射`，以及每个段号代表段的`长度`

### 分页

与分段的区别：段的长度可变，页的`长度固定`

物理页`frame`与逻辑页`page`大小是相等的

内存物理地址是一个二元组，两部分：页帧号f和帧内偏移o(f, o)

逻辑地址空间，也是二元组，分为页号p和页内偏移o(p, o)

物理地址和逻辑地址的`f与p大小可能不同`（逻辑地址空间可能比物理地址空间大），`o的大小是相同的`（每个页的长度相同）

页表维护`页号到帧号`的映射

### 页表

页表是一个`数组`，索引是页号，值是帧号

页表索引中还有`标志位`，0表示物理帧不存在，1表示存在

页表存在的问题：

- 1.页表可能占用很大空间，且不同进程拥有不同页表

- 2.访问一个内存单元需要两次内存访问（一次页表，一次数据）

解决方法：缓存和间接访问（分级）

- 缓存（时间）

通过TLB(Translasion Loos-aside Buffer)来缓存近期访问的页表项

TBL位于`CPU`中，速度更快

- 间接访问-多级页表（空间）

以二级页表为例，一级页表中的表项指向二级页表的起始地址（类似B+树）

优点在于，对于不存在的表项，`二级页表项可以不存在`，节省了空间

#### 反向页表

逻辑地址空间很大，就导致页表需要很大空间

反向列表是使页表与`物理地址空间相对应`，而不是与逻辑地址空间相对应

一种比较优化的方法是通过`hash(页号+PID)`的方法计算哈希值，从而找到帧号（页表是根据`帧号`建立的，是固定的）

## 虚拟内存

在没有虚拟技术之前，解决内存不足的主要手段有`覆盖技术`和`交换技术`

### 覆盖技术

将程序`分成模块`，不同时运行的模块可以共享同一块内存，在不同时间使用，互相覆盖

缺点是需要程序员自己管理

### 交换技术

将暂时不运行的进程交换到硬盘上（swap out），将正在运行的进程放到内存中（swap in），是对`整个进程`进行的操作

缺点是整个进程进行换进换出，开销很大

### 虚拟技术

虚拟技术解决了覆盖技术和交换技术的问题

虚拟技术能够有效执行依赖于程序的`局部性`（时间与空间，二维数组按照行列遍历），以及`分段或分页`的基本机制

#### 虚拟技术流程

- 装载程序时，只需要将`当前需要执行的部分页`装入内存，程序就可以开始执行

- 程序执行中，当遇到需执行的指令或访问的数据未在内存中（缺页），由CPU通知操作系统将相应的页载入内存，再进行访问，若此时没有空闲的内存空间，需要`牺牲一部分页`

- 将暂时不需要执行的指令或数据页保存在硬盘上

#### 虚拟技术基本特征

- 用户空间大，每个程序认为自己在独享`2^计算机位数`地址空间

- 部分交换，只对程序的某一部分在内存和硬盘之间交换

- 不连续性，物理内存分配不连续

#### 虚拟页式内存管理

页表表项：逻辑页号对应一些`标志位`和`物理页号`

标志位：

- 驻留位，1表示该页位于内存中，0表示不在，将导致缺页中断

- 保护位，表示允许的访问，如只读，可读写，可执行等

- 修改位，表示页在内存中是否被修改，0表示未被修改（与硬盘的数据一致），在切换时`不需要复制`到硬盘，，直接释放

- 访问位，1表示被访问，0表示未被访问，在置换时根据相应的算法使用

缺页中断处理：

- 1.如果内存中有空闲物理页，分配一个物理帧`f`，转到第4步，否则第2步

- 2.根据某种`页面置换算法`，选择某一个物理帧删除，它对应的虚拟页为q，如果发生过修改，要将数据`写回`到硬盘

- 3.将q的驻留位设为0，

- 4.将要访问的虚拟页`p`装入物理f中

- 5.`修改页表`中p对应的驻留位为1，物理帧为f

- 6.`重新运行`被中断的指令

#### 后备存储

有一些数据可能未被映射，比如一些动态库和运行时生成的数据，它们需要通过后备存储来存储到硬盘上

- 虚拟地址空间的页面可以映射到`文件`的某个位置

- 代码段可以映射到`可执行二进制文件`

- 动态加载的共享库映射到`动态库文件`

- 一些运行时数据可能被映射到`可交换文件`（swap file）

### 局部页面置换算法

功能：缺页中断发生，但物理内存已满时，选择物理内存中哪个页面被替换

目标：减少页面换入换出次数

#### 1.最优页面置换算法

思路：替换掉`将来最长时间不会访问到`的页面

因为将来无法预测，所以无法实现，可用作评价其他算法的标准（第二次运行时可以使用最优页面置换算法），与其他算法比较

#### 2.先进先出算法

选择驻留时间最长的页面替换

#### 3.最近最久未使用 LRU

替换最久未被使用的页面

是依据局部性原理来近似最优页面置换算法，根据历史推测未来

#### 4.时钟页面置换算法 Clock

LRU的近似，FIFO的改进

把页面组织成环形链表（时钟表盘），指针指向最老的页面

当发生缺页中断，考察指针指向页面的`访问位`，若为0，直接替换，若为1，将该页的访问位置0，然后顺序向后直到找到`访问位为0的页替换`

#### 5.二次机会法

修改Clock算法，除了访问位，还要加上`脏位`(写操作时置1)

区分读写可以`减少页面换出`(写回)

二次机会可以理解为给被写入的页面两次机会不被替换

#### 6.最不常用法 LFU

算则访问次数最少的页面替换

#### Belady现象

Belady现象表示在采用FIFO算法时，出现`物理页面数增加`，`缺页率反而提高`的异常现相

### 全局页面置换算法

实际运行的程序需要的物理页面可能`会变化`

#### 工作集模型

- 工作集

一个进程`当前`正在使用的`逻辑页面集合`

用时间t和工作集窗口w表示，一个工作集就是自`当前时刻t`开始，到`过去长度为w`的时间段内，访问过的`页面集和:W(t, w)`

- 常驻集

当前时刻，进程`实际驻留在内存`中的页面集和

常驻集达到某个数量后，给再多的物理页面对缺页中断次数的降低影响不大

所以要合理分配每个进程的常驻集，使得`总体的缺页次数最少`

#### 工作集替换算法

算法思想：随着程序运行，将`不在工作集中`的页面替换掉（`不是等到缺页时`才替换）

#### 缺页率页面置换算法

缺页率为`缺页次数/内存访问次数`，或缺页`时间间隔的倒数`

算法思想：当一个进程的缺页率高时，增加工作集，缺页率低时，减小工作集

当缺页时，计算上次缺页到现在的时间间隔，与一个阈值比较，如果时间比阈值大，说明缺页率低，就减小工作集

#### 抖动问题

进程的常驻集比工作集小得多，导致很多缺页中断，使运行速度变慢，这种现象称为抖动

## 进程

定义：一个具有一定独立功能的`程序`在一个`数据集合`上的一次`动态执行`过程

一个进程包括：

- 代码

- 数据

- 程序计数器

- 通用寄存器，堆、栈

- 系统资源，如文件等

进程的特点：

- 动态性：动态地被创建和执行

- 并发性：被处理器调度，在一段时间内运行多个进程

- 独立性：不同进程互相不影响

- 制约性：访问共享资源或进程间同步时产生制约

### 进程控制结构

描述进程的`数据结构`：进程控制块(Process Control Block, PCB)，操作系统为每个进程维护一个PCB

进程控制块是操作系统管理控制进程所用的信息集合，PCB用于描述进程的基本情况以及运行变化过程

PCB是进程存在的`唯一标志`

PCB包含三种信息：

- 1.进程表示信息，如本进程标识，父进程标识，用户标识

- 2.处理机状态信息保存区，保护运行现场信息，包括一些寄存器和栈指针

- 3.进程控制信息

### 进程的状态管理

#### 进程的生命周期

有五个生命周期状态：创建、运行、等待、唤醒以及结束

- 1.进程创建

有三种事件能引起进程创建：

1.`系统初始化`时

2.`用户请求`创建新进程

3.`正在运行的进程`执行了创建进程的`系统调用`

- 2.进程运行

`内核`选择一个`就绪进程`，让它占用处理器并执行

- 3.进程等待

有三种情况发生等待（阻塞）：

1.请求并等待系统服务，无法马上完成

2.启动某种操作，无法马上完成

3.需要的数据没有到达

进程只能`自己阻塞自己`

- 4.进程唤醒

有三种原因被唤醒：

1.被阻塞进程需要的资源能满足

2.被阻塞进程等待的事件到达

3.将该进程的PCB插入到就绪队列

进程只能被`其它进程`或`操作系统`唤醒

- 5.进程结束

有四种情况结束：

1.正常退出（自愿）

2.错误退出（自愿）

3.致命错误（强制）

4.被其他进程杀死（强制）

#### 进程状态变化模型

进程三种基本状态：

- 1.运行状态：正在处理器上执行

- 2.就绪状态：获得了除处理器外一切所需资源

- 3.等待（阻塞）状态：正在等待某一事件而暂停运行

还有两个状态：

- 1.创建状态：正在创建，到就绪状态之前

- 2.结束状态：正在从系统中消失，PCB还存在

状态转移过程：

[![2nVvp4.png](https://z3.ax1x.com/2021/06/01/2nVvp4.png)](https://imgtu.com/i/2nVvp4)

#### 进程挂起

进程挂起不同于阻塞，挂起的进程没有占用内存空间，而是被映射在`硬盘`上

- 阻塞挂起状态：进程在硬盘`等待事件`

- 就绪挂起状态：进程在硬盘，只要进入内存就可以运行

#### 状态管理

操作系统维护一组`状态队列`，不同的状态用不同的队列表示

每个进程的PCB根据状态加入相应的队列

### 线程

为了解决进程之间传递数据的大开销，提出一种能够`并发执行`，并且`共享地址空间`的新实体——线程

定义：线程是进程中的一条`执行流程`

进程负责`组合资源`，而线程是在进程的`资源平台`上运行的执行流程

线程也有`线程控制块`（Thread Control Block, TCB），TCB与PCB不同，它只管理执行相关的信息，如程序计数器、堆栈和寄存器

线程的优点：

- 1.一个进程中可以存在多个线程

- 2.多个线程可以并发执行

- 3.一个进程的各个线程共享地址空间和文件资源

缺点：

- 一个线程崩溃，`整个进程`都会崩溃

#### 进程与线程比较

- 进程是资源分配单位，线程是CPU调度单位

- 进程拥有完整的资源平台，线程只独享执行需要的资源

- 线程同样具有就绪、等待和执行三种基本状态

- 线程能减少并发的时间和空间开销（需要`分配`资源少，切换时不需要`切换`页表，统一进程的线程`共享`资源，可以不通过内核通信）

#### 线程的实现

线程主要有三种：用户线程、内核线程和轻量级线程

- 1.用户线程

在用户空间实现，操作系统看不见

操作系统只能看到`进程`，进程的管理由`线程库`来实现

缺点（`粗粒度`）：

1.因为操作系统只能看到进程，所以一个线程阻塞会导致`整个进程阻塞`

2.一个用户线程运行时，除非`主动`交出CPU运行权，否则该进程的其他线程无法运行

3.时间片是分配给进程的，所以多线程运行时，每个线程得到的`时间片更少`

- 2.内核线程

线程所有的创建、终止和管理都是由操作系统内核完成的

缺点：

每一次线程切换都有用户态到内核态的切换，开销更大

- 3.轻量级进程

内核支持的用户线程，每个轻量级进程由一个单独的内核线程来支持

### 上下文切换

进程切换时要保存一些运行状态，以便切换回来后可以继续运行，称为上下文

上下文包括程序计数器、栈指针、各种寄存器等

存储在`PCB`中

### 进程控制

#### 进程创建

`fork`创建子进程，代码、数据和地址空间都相同

#### 进程加载和执行

`exec`加载不同的程序并执行，会导致代码、数据和地址空间的改变 

通常调用fork后紧接着调用exec，所以fork中复制的数据都要被`覆盖掉`，为了节省这些开销，有两种方式：

- 1.vfork()，只复制一小部分信息，不复制数据

- 2.Copy On Write`写时复制`，fork创建子进程时，并不复制数据，只复制页表等`元数据`，当对某个页进行`写操作`时，将该页`复制成两份`，使得父进程和子进程拥有两份地址空间

#### 进程等待

`wait`父进程用来等待子进程的结束

当进程`exit`退出后，用户态的资源完全释放，但内核中还维护者进程的相关资源，如PCB，它无法被自己释放，所以子进程exit后，向父进程的`wait`返回一个值，父进程负责`回收资源`

#### 进程终止

`exit`结束进程

在子进程exit后到父进程wait执行前，子进程处于`僵尸状态`

如果父进程先于子进程退出，则会有大量僵尸进程，为了避免这种情况，`根进程`会定期扫描并清除僵尸进程

## 调度

发生调度的条件：

- 1.进程切换到等待状态

- 2.进程终止

`不可抢占`的进程：调度程序必须等待事件结束

`可抢占式`进程：

- 1.调度程序在中断被响应后执行

- 2.当前进程从运行切换到就绪，或其它进程等待切换到就绪

- 3.当前进程可以被换出

### 评价调度算法的指标

- CPU利用率，CPU处于忙状态所占时间的百分比

- 吞吐量（计算带宽），单位时间内完成的进程数量

- 周转时间，一个进程从开始到结束的所有时间

- 等待事件，进程在`就绪队列`中的总时间

- 响应时间（计算延迟），一个请求被提交到第一次响应花费的时间

### 调度算法

#### FCFS 先来先服务

先进入队列的进程先被服务

如果进程阻塞，则顺序执行下一个

优点：简单

缺点：

- 平均等待事件波动较大

- 执行时间短的任务可能排在时间长的任务后面

- 可能导致IO密集型等待CPU密集型任务，导致IO设备闲置

#### SPN 短进程优先

Sortest Process Next，选择`下一个最短`的进程服务

缺点：

- 连续的短任务可能导致`长任务饥饿`（不公平）

- 难以`预测`进程的执行时间

#### HRRN 最高响应比优先

Highest Response Ratio Next

R=`(等待时间+执行时间)/执行时间`

在SPN基础上改进，`R越大`表示等待时间越长，就优先调度，`不可抢占`

优点：

- 考虑了等待时间，防止饥饿现象

缺点：

- 难以预测执行时间

#### Round Cobin 轮询

设置某个`单位时间片t`（目前通常是1ms），让各个进程轮流占用CPU运行t个时刻

优点：

- 公平

缺点：

- 单位时间片过短，导致频繁切换，开小变大

- 单位时间片过长，导致等待时间边长

#### Mutilevel Feedback Queues 多级反馈队列

- 多级：将`就绪队列`分成不同级别的队列，对不同级别的队列使用`不同的调度算法`

- 反馈：让进程可以在不同优先级队列之间移动

为每个队列设置`单位时间片t`，优先级越高，`t越大`

如果一个任务在t时间内没有完成，就将它`降低一个级别`

这样可以使得CPU密集型任务优先级下降很快，IO密集型任务的优先级较高，交互性任务响应较快

#### Fair Share Scheduling 公平共享调度

用户组有不同的重要性

未使用的资源按照每个组使用的比例来分配

### 实时调度

实时系统：正确性依赖于`时间`和`功能`两方面的操作系统

强实时系统：`必须`在规定时间内完成重要的任务

弱实时系统：`尽量`在规定时间内完成

### 多处理器调度

在单处理器调度算法的基础上，实现`负载均衡`

### 优先级反转

高优先级任务`等待`低优先级任务占用的资源

解决方法：

- 1.当存在等待时，低优先级任务`继承`高优先级任务的优先级，使得低优先级任务不能抢占资源

- 2.为资源也设置优先级，资源的优先级与所有可以访问该资源的任务中`最高`的那个优先级，任务访问资源时，会将优先级提高到资源的优先级，如果资源正在被使用，则其它优先级低于资源的任务要等待

## 同步

独立的线程具有`确定性`和`可重现性`

多个进程共享资源时不确定和不可重现

- 原子操作，不能被打断的执行

- 临界区，访问共享资源的代码区域

- 互斥，一个进程处于临界区访问共享资源时，其它进程不能处于临界区访问共享资源

- 死锁，多个进程互相等待别人的资源

- 饥饿，一个进程长时间得不到执行

同步问题需要保证`对临界区的访问是互斥的`

### 临界区

临界区需要保证几个属性：

- 互斥，同一个临界区最多存在一个线程

- progress，如果一个线程要进入临界区，它`最终`会成功

- 有限等待，线程只需要等待有限的时间就能被执行

- 无忙等待（可选），线程在等待时会被`挂起`

有三种方法保护临界区数据：禁用硬件中断，软件方案以及更高级的抽象

### 1.禁用硬件中断

没有中断，就没有上下文切换，就没有并发

可以在`进入临界区之前`禁用中断

缺点：

- 中断被禁用，线程就无法停止，其他线程饥饿

- 临界区长度不确定，无法限制响应中断所需的时间，一些硬件事件会被影响

### 2.软件方法

在进入临界区之前加锁，出临界区后解锁

Peterson算法：

```
int turn         // 指示该誰进入临界区
boolean flag[]   // 指示是否准备好进入临界区

// 对于进程Pi:
while {
    // 进入临界区前
    flag[i] = TRUE
    turn = j
    while (flag[j] && turn=j)  // 让给别人
    // 执行临界区

    // 退出临界区后
    flag[i] = FALSE
}
```

需要忙等待

需要硬件支持：数据复制（LOAD和STORE）需要原子操作

### 3.高级抽象

借助硬件提供的原子操作

锁是一个抽象的数据结构，具有`锁定`和`解锁`两种状态，以及两个方法：

- Acquire，锁被释放前一直等待直到锁被释放

- Release，释放锁

#### 原子指令

- `测试和置位`（test-and-set），从内存中读值，然后测试该值是否为1并返回真假，然后将内存值设为1

- `交换`（exchange），交换内存中的两个值

#### test-and-set 实现锁

伪代码：

```
class Lock {
    int value = 0
}

Lock.Acquire() {
    while (test-and-set(value))  // 等待
}

Lock.Release() {
    value = 0
}
```

在Acquire方法中，test-and-set只有在value为0的时候`返回0`，跳出while循环，并将value`置为1`，阻止其他进程进入临界区

在Release方法中，将value设为0，此时其他进程就可以跳出while循环

在while循环时可以将进程`睡眠`，`防止忙等待`消耗资源

#### exchange 实现锁

伪代码：

```
int lock = 0
int key = 0

while {
    key = 1
    while (key == 1) {
        exchange (lock, key)
    }
    // 执行临界区
    // 退出临界区
    lock = 0
}
```

执行逻辑为：lock一开始为0，当第一个进程进入while循环时，通过exchange，lock=1, `key=0，跳出循环`

第二个进程执行时，`lock和key都为1`，所以一直停留在while循环，直到第一个进程退出临界区，将lock赋值为0


## 信号量

通过信号量可以实现功能更全面的同步

如：对于读操作，不需要互斥

信号量的数据类型：`整形（sem）`，具有两个`原子操作`

- P()，sem减1，如果`sem<0`就等待，否则继续，类似于加锁

- V()，sem加1，如果`sem<=0`（说明有通过P()操作等待的进程），就唤醒一个等待进程，类似于解锁

P()会`阻塞`（sem<0时），V()`不会阻塞`


### 信号量的使用

信号量的类型可以是二进制0或1（与锁相同），也可以是任何整数值（计数）

#### 用信号量实现锁

```
mutex = new Semaphore(1)  // 初始化为1

mutex.P()  //加锁
// 临界区
mutex.V()  //解锁
```

#### 用信号量实现调度约束

```
condition = new Semaphore(0)  // 初始化为0

// ThreadA:
{
    ...
    condition.P()
    ...
}

// ThreadB:
{
    ...
    condition.V()
    ...
}
```

ThreadA会在P()处`挂起`，直到ThreadB的V()操作执行完才能继续执行，实现流程控制

### 信号量的实现

信号量的数据结构可以抽象成：

```
class Semaphore {
    int sem
    WaitQueue q    // 等待被唤醒的线程队列
}

Semaphore.P() {
    sem--
    if sem < 0 {
        add thread to q
        block(thread)  // 阻塞线程
    }
}

Semaphore.V() {
    sem++
    if sem <= 0 {
        remove a thread from q
        wakeup(thread)  // 唤醒线程
    }
}
```

### 管程 monitor

管程用于`分离互斥`和`条件同步`

管程包括：

- `一个锁`，指定临界区

- `0个或多个条件变量`，等待和通知信号量

锁的实现与上面相同

条件变量主要有两个方法

- `Wait()`，释放锁，睡眠

- `Signal()`，唤醒等待者

### 读写者问题

写者互斥，读者不互斥

需要对读写进行不同的处理，锁的数据结构：

```
WriteMutex int 1   // 写操作的信号量
CountMutex int 1   // 读者数量的信号量
Rcount int 0       // 读者数量
```

对于写者：

```
P(WriteMutex)
write
V(WriteMutex)
```

对于读者（`读者优先`）：

```
P(CountMutex)   // 操作Rcount的时候要加锁
if Rcount == 0 {
    // Rcount为0，说明当前是第一个读者，为了保证与写操作的互斥，需要加写锁
    // 后面的读者可以不考虑写锁，直接进行读取
    P(WriteMutex)  
    Rocount++
}
V(CountMutex)

read

P(CountMutex)
Rocount--
if Rcount == 0 {
    // 最后一个读者要释放写锁
    V(WriteMutex)
}
V(CountMutex)
```

### 哲学家就餐问题

核心思想是：要么同时拿两把叉子，要么一把也不拿

每当需要吃饭时，判断左右邻居的状态，只有`左右邻居都没在吃`的时候才吃，并且在吃完之后判断左右邻居，如果他们需要吃，就`唤醒他们`

数据结构：

```
{
    int N                // 哲学家个数
    int LEFT i           // 左邻居
    int RIGHt (i+1)/n    // 右邻居
    int THINKING         // 思考状态
    int HUNGRY           // 饥饿状态
    int EATING           // 进餐状态
    state[N]             // 记录每个人的状态
    semaphore mutex      // 互斥信号量
    semaphore s[N]       // 同步信号量
}
```

## 死锁

两个进程互相等待对方的资源

通过资源-进程之间的`有向图`来表示系统模型

### 死锁的特征

如果有死锁，一定会出现以下特征（`必要不充分`）：

- `互斥`，在一个时间只能有一个进程使用资源

- `持有并等待`，进程至少持有一个资源，并正在等待其他进程持有的资源

- `无抢占`，资源只能由进程主动释放

- `环形等待`，多个进程互相等待别人的资源

### 死锁的处理

#### 死锁的预防

打破四个特征中的某一个

- 打破互斥，有可能导致并发的不确定性

- 打破持有并等待，类似哲学家进餐，要么获得全部资源，要么一个资源也不获取，可能导致资源利用率低，程序效率低

- 打破无抢占，在死锁时杀死其中一个进程

- 打破环形等待，将资源排序，必须按顺序申请，就不会形成环，但也会导致资源利用率较低，而且有排序的开销

#### 死锁的避免

系统需要具有额外的验证信息，如

- 每个进程声明需要某个资源的`最大数目`，当申请资源超过最大数目时不予分配

- `动态检查`资源分配状态，确保不会出现环形等待（检查`安全序列`，pi需要的资源能够用当前资源+p0到pi-1的资源来满足）

一个著名死锁避免算法：`银行家算法`

以银行借贷作为类比

`数据结构`：

```
n 进程数量
m 资源类型数量

Max 总需求量，n×m矩阵，Max[i, j] = k表示进程Pi最多请求资源类型Rj的k个实例

Available，剩余空闲量，长度为m，Available[j] = k表示有k个Rj类型的资源实例可用

Allocation，已分配量，n×m矩阵，Allocation[i, j] = k表示进程Pi当前分配了k个Rj的实例

Need，未来需要量，n×m矩阵，Need[i, j] = k表示Pi可能需要k个Rj来完成任务
```

`安全状态判断算法`：

- 1.初始化 

```
Work = Available                      // 当前剩余空闲量
Finish[i] = false for i in range n    // 进程程i没结束
```

- 2.找到这样的进程：

```
Finish[i] = false     // 进程没结束
Need[i] <= Work[i]    // 需要的资源少于剩余量
```

如果找到就跳到3，否则跳到4

- 3.满足2中的条件，认为进程`可以正常结束`，就回收

```
Work = Work + Allocation      // 回收资源
Finish[i] = true              // 结束
```

完成后回到2

- 4.不满足2的条件，要判断所有进程能不能正常结束

```
if Finish[i] == true for i in range n   // 所有进程能正常结束
    // 安全状态
else
    // 不安全状态
```

通过上面的算法最终可以找到`安全的执行序列`

`银行家算法`

- 1.初始化

```
Request[i][j] = k   // 进程Pi需要k个Rj的实例
```

- 2.判断需求

如果Request[i][j] < Need[i][j]，表示进程超过了其`最大需求量`，直接返回false

否则跳转3

- 3.判断可用

如果Request[i][j] <= Available，说明没有足够的可用资源，`Pi等待`

否则跳转4

- 4.`假设`给Pi分配资源

```
Available = Available - Request
Allocation = Allocation + Request
Need = Need - Request
```

将三个状态传递给`安全状态判断算法`，如果返回true，说明`可以分配`，如果返回false，则需要等待

#### 死锁检测

`允许`系统进入死锁，检测到死锁后`恢复`

判断等待图中是否有`环`

如何恢复：

- 依次杀死进程直到死锁恢复，可以按照优先级、运行时间、资源占用量，资源需求量等顺序

### 进程间通信 IPC

多个进程协作需要进程间能够通信

分为直接通信和间接通信（通过管道等）

具体方式方式包括：

- 信号

- 管道

- 消息队列

- 共享内存

- socket

#### 直接通信

直接通信要求进程要正确的`命名对方`

方法：

- send(p)，发送信息到进程p

- receive(q)，从进程q接收消息

通信链路：

- 链路自动建立

- 每条链路对应一对进程

- 每对进程间只有一个链路存在

- 链路通常为双向

#### 间接通信

从指定的`消息队列`接收消息

每个消息队列有一个固定的ID

进程`共享`一个消息队列，才可以建立链路

链路与进程是多对多的关系

#### 信号

`软件中断`通知进程进行事件处理

处理方式：

- 1.直接挂起进程

- 2.忽略信号

- 3.指定对应的信号处理方法

缺点：`不能传递数据`

需要修改应用程序的`堆栈`，使得指向信号处理程序的地址

#### 管道

管道是内核中的一段buffer，将前面进程的输出作为后面进程的输入

让两个进程`共享一段buffer`

需要两个进程继承自`同一个父进程`，才能共享

管道中传递的是`字节流`

#### 消息队列

可以在多个`不相干的进程`之间传递信息

可以传递`结构化的数据`，而不是字节流

#### 共享内存

直接通信

在地址空间内设置了`共享内存段`

优点：速度快

缺点：必须同步访问

## 文件系统

用于`持久性存储`的系统抽象

文件：文件系统中一个`单元`的相关数据在操作系统中的抽象

文件头：保存文件的属性，并跟踪文件属于哪个存储块

### 文件描述符

文件描述符是`整型`，是内核维护的进程`打开文件表`的`索引`

### 文件访问

管理打开文件需要的元数据：

- 文件指针，指向最近一次的读写位置

- 文件打开计数，最后一个进程关闭了文件时，可以将其从打开文件表移除

- 文件磁盘位置

- 访问权限

将程序以`字节`为单位的读写与硬盘的以`扇区`为单位的读写关联起来，读取时会将硬盘上一整个扇区拷贝到内存，然后读取扇区内的对应字节

操作系统将所有文件统一理解为`字节流`

通过`读/写/执行`来对文件权限进行标识

共享访问有两种：

- Unix文件系统（UFS）语义：对打开文件的写入立即对打开同一文件的其他用户`可见`，且通过共享指针允许`同时读取和写入`

- 会话语义，写入内容只有文件`关闭`时可见

### 目录

目录是`特殊的文件`，文件通过目录的方式组织起来

每个目录包含一张`表`

文件系统需要被`挂载`才能被访问，可以挂载不同类型的文件系统

### 文件别名

两种实现方式：

- 1.硬链接，多个文件项指向同一个文件（不同文件项存储的是相同内容）

- 2.软链接，以`快捷方式`指向其他文件（软连接存储的是实际文件的路径）

### 文件系统种类

- 磁盘文件系统：FAT，NTFS，ext2/3，IS09660等

- 数据库文件系统

- 日志文件系统，记录文件系统的修改

- 网络/分布式文件系统

- 特殊/虚拟文件系统

### 虚拟文件系统

通过虚拟文件系统来`屏蔽`底层不同文件系统的差异性，对用户提供`统一的API`

- 卷控制块，每个文件系统一个

- 文件控制块，每个文件一个

- 目录节点，每个目录项一个

### 数据块缓存

内存与硬盘的访问速度相差很大，所以在内存中`缓存`一部分常用的数据有助于提高访问效率

通常是`页缓存`，将文件数据块映射成内存中的页

### 打开文件

打开文件：

- 1.找到文件在硬盘上的位置

- 2.将文件数据拷贝到内存

- 3.将文件信息放到`打开文件表`中，向应用程序`返回`打开文件表的索引（文件描述符）

### 为文件分配数据块

- 连续分配，文件头包括`起始块`和`长度`

优点：适合连续读取

缺点：可能有碎片，且存在文件`增长`问题

- 链式分配，以数据块链表形式存储，文件头包含到`第一块`和`最后一块`的指针

优点：创建和修改容易，没有碎片

缺点：必须串行访问，效率低，任何一个链失效导致文件失效，`可靠性差`

- 索引分配，为每个文件创建名为`索引数据块`的非数据数据块，文件头包含索引数据块

优点：创建与修改容易，没有碎片，随机访问

缺点：建立索引的开销

### 空闲数据块

空闲数据块的表示方法

- 位图，0标识空闲，1表示已分配

### 多磁盘管理 RAID

分区：将硬件磁盘根据操作系统格式进行划分

卷：拥有一个文件系统实例的可访问存储空间，一个卷可以包含多个磁盘

RAID，`冗余磁盘阵列`，可以提高吞吐量(`并行`)与可靠性

RAID对操作系统提供统一的`虚拟硬盘`（类似于操作系统向用户程序提供的虚拟内存）

RAID的发展：

- RAID0：并行，将数据拆分存储在不同硬盘上，读取时可以并行读取

- RAID1：可靠，在两个硬盘上写同样的内容，`镜像`

- RAID5：用不同的硬盘分别实现并行和可靠，有一个`奇偶校验盘`，以`block`为单位来进行校验

### 磁盘调度

访问数据时，磁头需要在`期望的磁道`，并从`期望的扇区`开始

找到磁道所花费的时间称为`寻道时间`，找到扇区的时间称为`旋转延迟`

寻道时间是主要的耗时操作，优化方法：只在磁头`运动的一个方向`上扫描
