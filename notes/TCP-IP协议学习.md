# 基础知识

TCP(Transmission Control Protocal) 传输控制协议

它提供了任意长度消息的可靠传输，定义了所有类型数据在网络中的一种健壮传递机制

IP(Internet Protocal) 网际协议

它管理从发送方到接收方的网络传输的路由，并处理于网络和计算机寻址相关的问题


IPV4 32位

IPV6 可以支持128位，目前运营商提供的一般为64位

## ISO/OSI 网络参考模型

ISO/OSI全名 International Organization for Standardization Open Systems Interconnection (国际标准化组织开放系统互连)

前四层为主机层，后三层为介质层

|  数据   | 分层  |
|  :----:  | :----:  |
| 数据  | 应用层 |
| 数据  | 表示层 |
| 数据  | 会话层 |
| 数据段  | 传输层 |
| 分组  | 网络层 |
| 数据帧  | 数据链路层 |
| 比特位 | 物理层 |

一般来说，各层为上一层提供服务，并向下一层交付数据或从下一层接收数据

PDU（Protocal Data Unit，协议数据单元）是在各层传输的数据包

### 1.物理层

物理传输介质（电缆或无线传输介质）

任务是建立、维持和断开网络连接

物理层管理`网络介质`到`协议栈`的通信，发送时将出栈数据转换为网络信号，接收时相反

物理层的数据（PDU）由串行信号组成，对应数据链路层里数据帧的比特位

### 2.数据链路层

任务是确保在`发送方`实现物理层数据的可靠传输，在`接收方`

通过唯一标识每一个网卡的专用地址，识别本地介质上的每个设备

管理网卡之间的`点对点`通信

`介质流控制` 数据链路层能够控制从发送方到接收方数据传输的节奏

### 3.网络层

主要功能是对Internet上的每一个主机提供一个`全球唯一的地址`，并提供主机之间的通信路径

包含DNS（Domain Name System，域名系统）

- 分组交换
- 阻塞控制


### 4.传输层

确保发送方到接收方PUD可靠的端到端传输

在这一层需要进行数据`校验`

数据的`分段`与`重组`：在发送方分段，接收方重组

传输层的PDU称为`数据段`

### 5.会话层

会话层是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方

通过`检查点`机制来维持可靠会话

### 6.表示层

表示层管理从`网络通用的数据`到`特定机器（或应用程序）`上的数据变换，以及反向变换

`重定向器`（或网络外壳）：将本地资源请求与网络资源请求区分开

### 7.应用层

应用程序用于请求网络程序的`接口`，而不是应用程序本身

应用层定义了应用程序能够从网络上请求的几种类型的`服务`，并且规定了`数据所采用的格式`

## TCP/IP网络模型

是与OSI参考模型对应的另一种模型，它分为4层

### 1.网络访问层

对应物理层+数据链路层

PPP(Point to Point Protocal)点对点协议，用于在两个网络设备之间建立直接的连接

网络访问层（OSI第二层）还包括一些不属于TCP/IP协议族的协议：

- HDLC（High-level Data Link Control) 高速数据链路控制协议
- 帧中继（Frame Raley）
- ATM （Asynchronous Transfer Mode） 异步传输模式


### 2.互联网层

对应网络层

主要有三个基本功能：数据分片、寻址、路由

互联网层的主要协议：

- IP （Internet Protocal） 网际协议：负责把数据包从发送方路由到接收方
- ICMP （Internet Control Message Protocal） Internet控制消息协议
- ARP （Address Resolution Protocal） 地址解析协议：IP地址--MAC地址
- RARP （Reverse Address Resolution Protocal） 反向地址解析协议：MAC地址--IP地址
- BOOTP （Bootstrap Protocal） 自举协议
- RIP （Routing Information Protocal） 路由信息协议：定义了`跳数`（发送方到接收方经过的路由器个数）
- OSFP （Open Shortest Path First） 开放式最短路径优先协议
- BGP （Border Gateway Protocal） 边界网关协议

### 3.传输层

对应传输层

提供了一台主机到另一台主机的数据移动

基本功能包括发送方到接收方的`可靠数据传输`、出站前必要的`消息分段`以及在把数据交给应用层之前`重组分段`

传输层的协议有两个：

- TCP （Transmission Control Protocal） 传输控制协议

`面向连接的`协议，发送数据之前在发送方和接收方之间协商并`维持连接`

- UDP （User Datagram Protocal） 用户数据报协议

`无连接的`协议，以一种“尽最大努力交付”的方式简单地发送数据，在接收方没有任何后续的检验

### 4.应用层

对应会话层+表示层+应用层

协议栈与主机上的应用程序进行交互的地方

TCP/IP服务的运行依赖于两个要素：`守护进程`和`端口地址`


## 套接字

特定`IP地址`+`动态分配端口号`的组合称为套接字地址（Socket Address），简称套接字（Socket）

动态分配端口号指的是`1024~65536`之间的，在需要时为发送方和接收方之间提供有限数据交换的`临时`连接时用到的端口号


# 《计算机网络：自顶向下方法》

## 网络核心

网络核心指的是因特网端系统的分组交换机和链路构成的网状网络

### 分组交换

为了从源端向目的端发送一个报文，源将长报文划分为较小的数据块，称为`分组`

每个分组通过通信链路和`分组交换机`传送。分组交换机主要有两类：`路由器`和`链路层交换机`

#### 1.存储转发传输

存储转发传输指的是交换机必须等待整个分组`全接收完`才能开始发送

#### 2.排队时延和分组丢失

类似于买东西排队，当数据量大时，数据需要在分组交换机的`输出队列`中进行等待

#### 3.转发表和路由选择协议

类比于问路，数据想要去往目的地，数据包的首部包含了目的地的`IP地址`，通过路由器进行“问路”，但中间的路由器并不知道如何去往最终的目的地，它只是知道经由附近的哪个路由器能够
最终走到目的地（`路由表`），所以它将数据转发给相邻的路由器，由此一步步数据最终能够被发送到目的地


### 电路交换

与分组交换不同，电路交换会为即将到来的数据传输`预留资源`，当数据发送时，不需要等待就可以直接传输

这样带来的弊端就是因为要为其他的数据传输预留资源，所以电路交换的每一个传输都只能使用`一部分的链路传输资源`


### 分组交换网中的时延

有以下几种时延：节点处理实验，排队时延，传输时延和传播时延，加起来是节点总时延

#### 1.处理时延

包括检查分组首部和决定该分组导向何处等

#### 2.排队时延

如果当前传输队列有其他分组正在传输，当前分组就需要等待

#### 3.传输时延

指的是将所有比特推向链路所需要的时间（这部分在节点内部完成）

#### 4.传播时延

从起点到终点需要的时间（在路上）

### 分组交换网中的丢包

丢包与`排队时延`有关，需要先说明一个概念：`流量强度`

- 流量强度

如果a表示分组到达队列的平均速率，R表示传输速率，L表示该分组由L个比特组成

则流量强度等于`La/R`

假如`La/R>1`，则比特到达队列的平均速度将超过传输出去的速度，丢列趋于无限增加，所以设计系统时`流量强度不能大于1`

- 丢包

当流量强度小于1的时候，随着流量强度接近1，排队时延并不趋向无穷大，相反，到达的分组将发现一个满的队列，由于没有地方存放这个分组，路由器将`丢弃`该分组，这就是丢包


### 吞吐量

若令Rs表示服务器与路由器之间的链路速率，Rc表示路由器与客户之间的的链路速率，这一两链路网络的吞吐量就是`min(Rs, Rc)`，就是所有速率中的最小值

而如果存在一条共享链路，其速率为R，假设允许同时存在10个传输，则吞吐量为`min(Rs, Rc, R/10)`，即共享链路的速率会被`平分`


## 因特网的5层协议栈（自顶向下）

### 1.应用层

包括网络应用程序以及它们对应的协议

HTTP、FTP、DNS等

数据为`报文`

### 2.传输层

在`应用程序端点`之间传输应用层报文

TCP、UDP

数据为`报文段`

### 3.网络层

负责将数据分组从一台主机移动到另一台主机

IP协议

数据为`数据报`

### 4.链路层

为了将分组从一个节点移动到下一个节点，网络层必须依靠链路层的服务

在每个节点，网络层将数据报`下传`给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据报`上传`给网络层

数据为`帧`

### 5.物理层

将数据帧中的一个个`比特`从一个节点移动到下一个节点

数据是`比特`

### 封装

在发送端，数据自上而下层层封装，每一层都加上该层特有的信息

在接收端，数据自下而上层层解封，每一层都去掉关于该层的信息


# 应用层

## 应用层协议原理

### 体系结构

应用层主要有两中应用程序体系结构：`客户-服务器体系结构`和`对等（P2P Peer to Peer）体系结构`

- 客户-服务器体系结构

客户-服务器体系结构中有一个`总是打开的主机`称为服务器，允许许多客户主机的请求

而且服务器具有`固定的、周知的`地址

- P2P体系结构

P2P体系结构对位于数据中心的专用服务器有最小的（或没有）依赖，应用程序在间断连接的`主机对`之间`直接通信`，这些主机称为`对等方`

P2P体系具有`自扩展性`

### 进程通信

进行端与端通信的是`进程`，两个不同端系统上的进程，通过网络交换`报文`而相互通信

在一对进程之间的通信中，将`发起通信`的进程标识为客户，在会话开始时`等待联系`的进程是服务器

进程通过称为`套接字`的软件接口向网络发送报文和从网络接收报文，套接字也称为`应用程序编程接口(Application Programming Interface API)`

套接字是同一台主机内`应用层`与`传输层`之间的接口

在通信中`主机`由`IP地址`标识，`在目的主机中指定接收的进程`由`端口号`标识

### 应用程序对传输层的要求

应用程序对传输层的要求大体有四个方面：可靠数据传输、吞吐量、定时和安全性

### 因特网提供的运输层服务

- TCP: 面向连接、可靠的数据传输

由于TCP不提供加密机制，所以研制出了`SSL（Secure Sockets Layer）安全套接字层`，它能提供`进程到进程`的安全性服务，SSL是一种`对TCP的加强`，这种强化是在`应用层`实现的

- UDP: 无连接、不可靠的数据传输、没有阻塞控制机制

## Web 与 HTTP

`Web`页面是由对象组成的，一个对象可以是一个HTML文件、一个图片，Java小程序等

多数页面由一个HTML基本文件以及几个引用对象（比如几张图片）组成，HTML基本文件通过`对象的URL地址`引用页面中的其他对象，URL地址由`存放对象的服务器主机名`和`对象的路径名`两部分组成

`HTTP`（HyperText Transfer Protocal 超文本传输协议）是Web的核心，它使用`TCP`作为支撑传输协议，且HTTP服务器不会保存客户状态的信息，所以说HTTP是一个`无状态协议`

### 持续连接与非持续连接

- 持续连接：所有的请求及其响应都由相同的TCP连接发送

- 非持续链接：每个请求/响应对是经由一个单独的TCP连接发送

HTTP默认使用`持续链接`，但也可以配置成非持续连接

非持续连接需要为`每一个对象`的请求建立和维护一个全新的TCP连接，这将给服务器带来严重的负担

而持续连接中，对所有对象的请求可以一个接一个的发出，而`不必等待对未决请求的回答`，当一条连接经过`一定时间间隔`仍未被使用，HTTP服务器将关闭这个连接

- RTT（Round-Trip Time 往返时间）指的是一个`短分组`从客户到服务器再返回客户所需的时间


### HTTP报文格式

HTTP报文由请求报文和响应报文两种

#### 请求报文

下面给出一个典型的HTTP请求报文格式

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

HTTP请求报文的第一行叫做`请求行`，后继的行叫做`首部行`

请求行有三个字段：`方法字段`、`URL字段`和`HTTP版本字段`

- 方法字段，包括GET, POST, HEAD, PUT和DELETE
- URL字段，它带有请求对象的标识
- HTTP版本字段，表示了使用的协议版本

在首部行中

- `HOST: www.someschool.edu` 指明了对象所在的主机，该信息是Web高速缓存所需要的
- `Connectioin: close` 告诉服务器使用非持续连接
- `User-agent: Mozilla/5.0` 指明用户代理，即发送请求的浏览器版本
- `Accept-language: fr` 表示想要得到该对象的法语版本

在HTTP报文中，首部行之后还有一个`实体体`，使用GET方法时，实体体为空，当使用POST方法时使用实体体

当然想要提交表单时也可以通过在URL中带上参数来实现

其他的一些方法字段：

- HEAD：与GET类似，但服务器接收到HEAD请求时只会返回HTTP报文，`不会返回对象`
- PUT：允许用户上传对象到服务器的指定位置
- DELETE：允许用户删除服务器上的指定对象

#### 响应报文

下面是一个典型的响应报文：

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last_Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data ...)
```

它有三个部分：一个初始`状态行`、6个`首部行`、以及`实体体`

状态行有三个部分：`协议版本`、`状态码`和`状态信息`

在首部行中：

- `Connection: close` 告诉用户，发送完报文后将关闭TCP连接
- `Date` 指示服务器产生并发送该响应报文的时间
- `Server` 指示服务器版本（与User-agent类似）
- `Last-Modified` 表示对象创建或者最后修改的时间
- `Content-Length` 指示被发送对象的字节数
- `Content-Type` 指示被发送对象的格式

常见状态码及相关短语

- 200 OK：请求成功，信息在返回的响应报文中
- 301 Moved Permanently：所请求的对象已经被永久转移了，新的URL在响应报文的`Location`首部行中，用户软件可以`自动获取`新的URL
- 400 Bad Request：指示该请求不能被服务器理解
- 404 Not Found：请求的文档不在服务器上
- 505 HTTP Version Not Supported：服务器不支持该请求报文的HTTP版本

### cookie

cookie可以在无状态的HTTP上建立一个`用户会话层`

在一次会话中设置cookie的流程为：

- 1.用户A首次访问服务器，服务器为A生成一个`唯一识别码`，并以此为索引在后端数据库产生一个表项
- 2.服务器用一个包含`Set-cookie`首部的响应报文对用户A的浏览器返回响应，假设该唯一识别码为1234，则首部行为`Set-cookie: 1234`
- 3.浏览器接收到响应后，在它管理的cookie文件中添加一行内容，包含`服务器主机名`和`唯一识别码`
- 4.当A再次访问该服务器时，浏览器会自动抽取cookie文件中的内容，放在报文首部中，以`cookie: 1234`的格式发送，服务器就可以识别出是哪个用户

由上述过程，可以看出cookie技术有四个组件：

- 1.服务器响应报文中的Set-cookie首部行
- 2.请求报文中的cookie首部行
- 3.服务器上的后端数据库
- 4.用户端有一个cookie文件，并由浏览器管理

### Web缓存

Web缓存器也叫代理服务器，是能够`代表初始服务器`来满足HTTP请求的网络实体，它`既是客户又是服务器`

带有Web缓存器的会话过程如下：

- 1.浏览器向Web缓存器中的对象发起请求
- 2.Web缓存器检查本地是否保存了所请求对象的`副本`，如果有就向浏览器直接返回
- 3.如果没有副本，Web缓存器就向`初始服务器`请求该对象
- 4.Web缓存器请求到对象之后，在本地保存一个副本，再将该副本返回给浏览器

Web缓存器的优点：

- 1.能够大大减少对客户请求的响应时间
- 2.能够大大减少一个机构的接入链路到因特网的通信量
- 3.大大降低因特网上的通信流量，增加应用性能

### 条件GET方法

有时放在Web缓存器上的对象可能在初始服务器上进行了修改，这样由于缓存机制用户就不能够获取到最新版本的对象

为此，HTTP提供了一种机制，允许缓存器证实它的对象是最新的，这种机制就是`带条件的GET方法`

这种机制应用在`Web缓存器 -> 初始服务器`的会话中，方法仍然是GET，但要加上`If-modified=since`首部，比如

```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
```

注意If-modified-since后面的时间其实是`上一次`Web缓存器从初始服务器上获得该对象的时间

如果初始服务器上的对象没有修改过，服务器将`只返回一个响应报文`，而不会返回对象内容


## 电子邮件SMTP

电子邮件系统包括`用户代理`、`邮件服务器`和`简单邮件传输协议（Simple Mail Transform Protocol SMTP）`

发送方和接收方各有一个邮件服务器

STMP一般不使用`中间服务器`

默认使用25号端口


## DNS 域名系统

DNS（Domain Name System）是将主机名转换到IP地址的目录服务，它有两部分

- 1.一个由`分层的DNS服务器`实现的`分布式数据库`
- 2.一个使得主机能够查询分布式数据库的`应用层协议`

DNS服务器通常是运行BIND的UNIX及其

DNS运行在`UDP`之上，使用53号端口

DNS通常是被其他应用层协议所使用的，比如当发送一个HTTP请求到www.someschool.edu时：

- 1.浏览器从URL中抽取出主机名。并将主机名传给`用户主机上DNS应用的客户端`
- 2.DNS客户向DNS服务器发送一个包含主机名的请求
- 3.DNS服务器返回一个包含对应主机名的IP地址的回答报文
- 4.本地DNS将IP地址发给浏览器，浏览器向该IP地址80端口的HTTP服务器发起一个TCP连接

DNS还有一些重要的功能：

- 1.主机别名：复杂的主机名（`规范主机名`）通常有一些易于记忆的主机别名，DNS也可以通过主机别名来获得IP地址
- 2.邮件服务器别名
- 3.负载分配：繁忙的站点可能运行在多个服务器上，它们通过一个`IP集合`与`规范主机名`绑定，在这种情况下，DNS可以在回答中`循环这些地址`，达到负载均衡的目的

### DNS的分布式、层次数据库

为了处理扩展性问题，DNS使用了大量的DNS服务器，它们以`层次`结构组织，大致来说供由3个层次：`根DNS服务器`、`顶级域（Top-Level Domain TLD）DNS服务器`和`权威DNS服务器`，其实还有一个`本地DNS服务器`（但它不算入DNS的层次结构中）

一个DNS服务的例子（书上P87）

假设本地主机名为`cse.nyu.edu`，本地DNS服务器为`dns.nyu.edu`，目标主机`gaia.cs.umass.edu`的权威DNS服务器为`dns.umass.edu`

- 1.主机首先向本地DNS服务器发送一个DNS查询报文，该报文包含目标主机名
- 2.本地DNS服务器将报文转发到根DNS服务器，根DNS服务器注意到`edu`后缀并向本地DNS服务器返回`负责edu的TLD的IP地址列表`
- 3.本地DNS服务器再次向这些`TLD之一`发送查询报文，TLD注意到`umass.edu`后缀，并向本地DNS服务器返回`权威DNS服务器的IP地址`，该权威DNS服务器就是`dns.umass.edu`
- 4.本地DNS服务器直接向权威DNS服务器查询报文，权威DNS服务器用目标主机`gaia.cs.umass.edu`的IP地址作为响应，查询成功

通常，向本地DNS服务器查询的方式是`递归查询`，其余是`迭代查询`

使用`DNS缓存`机制可以改善DNS服务的时延情况

### DNS记录和报文

所有的DNS服务器都储存了`资源记录（Recourse Record RR）`，RR提供了主机名到IP地址的映射

RR包含以下四个字段

```
(Name, Value, Type, TTL)
```

更多内容可以查看书P89

## P2P文件分发

在P2P文件分发中，每个`对等方`能够向任何其它对等方重新分发`它已经接收到的该文件的任何部分`

P2P是`自扩展的`

参与一个特定文件分发的所有对等方的集合称为一个`洪流（torrent）`，每个洪流中有一个`追踪器`，当一个新的对等方加入洪流时，追踪器随机的在洪流集合中
选取一个子集，并将它们的IP地址发给当前对等放方，当前对等方会与它们建立`并行的TCP连接`

`最稀缺优先`：当前对等方针对自己没有的块向邻居中找到最稀缺的块

`最高速率优先`：优先与最高速率的邻居连接

## 视频流和内容分发网

流视频的实现方式是使用`应用层协议`和以`高速缓存方式运行的服务器`

### 内容分发网

为了应对向全世界的用户分发巨量视频数据的挑战，几乎所有的主流公司都利用`内容分发网（Content Distribution Network CDN）`

CDN管理分布在`多个地理位置上的服务器`，在它的服务器中存储视频的副本（类似于因特网缓存）


### 套接字编程

具体程序请查看书P104

一个需要注意的点是TCP连接时服务器上有多个套接字，分为两种：

- 1.欢迎套接字

欢迎套接字是创建服务器应用时监听端口`等待用户连接`的那个套接字

- 2.连接套接字

连接套接字是与用户建立了连接之后为每个专门的用户`新生成的套接字`，可以有多个


# 运（传）输层

运输层协议为在不同主机上的`应用进程`之间提供了`逻辑通信`功能

运输层协议是在`端系统中`而不是在路由器中实现的

运输层在一次会话中承担的任务如下：

- 1.在发送端，运输层将从应用程序接收到的报文转换成运输层分组（`报文段`），一种方法是将报文划分为较小的块，再为每一块加上一个`运输层首部`以生成运输层报文段
- 2.然后在发送端系统中，运输层将报文段传递给`网络层`，网络层将其封装成网络层分组（`数据报`）并向目的地发送（注意网络路由器只作用于网络层分组，不检查运输层报文段的字段）
- 3.在接收端，网络层从数据报中提取运输层报文段，传递给运输层，运输层再处理报文段，将数据传递给应用程序

## 运输层与网络层的关系

网络层提供的是不同`主机`之间的逻辑通信，而运输层提供的是不同主机上的`应用进程`之间的逻辑通信

运输层协议能够提供的服务常常受制于底层网络层协议的服务模型

## 多路复用与多路分解

多路复用与多路分解就是将由网络层提供的`主机到主机`交付服务延伸到为运行在主机上的应用程序提供`进程到进程`的交付服务

接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的`套接字`

- 在接收端，将运输层报文段中的数据交付到正确的套接字的工作称为`多路分解`
- 在源主机，从不同套接字中收集数据块，并为每个数据块封装首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为`多路复用`

在运输层报文段中含有`源端口号字段`和`目的端口号字段`（每个端口号字段16位）

### UDP连接中的多路复用与多路分解

一个UDP套接字是由一个`二元组`标识的，它包含一个目的IP地址和一个目的端口号

运输层根据目的端口号将报文段交付给对应的套接字

### TCP连接中的多路复用与多路分解

一个TCP套接字是由一个`四元组`标识的，它包含源IP地址、源端口号、目的IP地址和目的端口号

运输层根据所有4个字段来定向到相应的套接字

## 无连接运输 UDP

UDP协议可以看作只是为网络层协议增加了`复用/分解`功能和少量的`差错检测`

UDP相对于TCP的优势：

- 1.关于发送什么数据以及何时发送的`应用层控制`更为精细，因为UDP几乎不对传输进行限制，诸如拥塞控制等
- 2.无需连接建立，能够节省时间
- 3.无连接状态，能够省去维护连接的资源消耗
- 4.分组首部开销小，TCP报文段首部是`20字节`，而UDP是`8字节`

### UDP报文

UDP报文段的首部有`4个字段`，分别为`源端口号`、`目的端口号`、`长度`和`校验和`每个字段`2字节`

源端口号在返回响应时使用，目的端口号在进行多路分解时使用，长度字段只是了UDP报文段中的`字节数（首部加数据）`，校验和用来检测数据是否出现了差错

### UDP校验和

校验和用于检测报文段从源到目的移动时，其中的比特是否发生了改变

发送方的UDP对报文段的所有`16比特的字的和`进行`反码`运算，得到校验和（可以看一下书上P133的例子）

最终在接收端，所有的16比特字（包括校验和）加在一起应该是`0xffff`

## 可靠数据传输原理

通过可靠数据传输协议，传输的数据比特不会受到损坏或丢失，而且所有数据都是按照发送顺序进行交付

### 一个可靠数据传输模型

- 1.自动重传请求（Automatic Repeat reQuest ARQ）协议

接收方向发送方返回确认信息，`肯定确认（ACK）`表示当前分组被正确接收，`否定确认（NAK）`表示当前分组有误并需要`重新发送`

ARQ协议需要实现三个功能：`差错检测`、`接收方反馈`和`重传`

注意当发送方处于等待ACK或NAK的状态时，它`不能继续从上层获得数据`，称之为`停等协议`

- 2.分组序号

在ARQ协议中，如果ACK或NAK分组受损，发送方将无法判断数据发送情况

为解决这个问题，使用最广泛的方法是在数据分组中添加一个新的字段，让发送方对数据分组`编号`，并发送其`序号`（分组序号在0和1之间交替，如果出现`相邻的0或1`则认为后面的分组是`重传`）

- 3.丢包

解决丢包问题的关键是`怎样检测丢包`以及`发生丢包之后该做什么`

实践中采取的方法是发送方设定一个`时间`，如果在这个时间内没有收到ACK，则认为发生了丢包，`重传`该分组

发送方应该做到：

- 1.每次发送一个数据分组，便启动一个定时器
- 2.响应定时器中断
- 3.终止定时器

可以看出这种模型的重点有三：`应答`、`序号`和`超时`

*书上P142图*


## 面向连接的运输 TCP

TCP是面向连接的，因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个`进程`必须先`握手`

TCP是`双向的`（书库可以从进程A流向进程B，也可以从B流向A）、`点对点的`（TCP只能是单个发送方与单个接收方之间的连接）

简单描述TCP连接的建立：客户首先发送报文段1，服务器用报文段2来响应，最后客户用报文段3响应，前两个报文段`不包含应用层数据`，而第三个报文段包含。这种连接建立过程被称为`三次握手`

一些概念：

- 1.发送缓存：发送缓存是三次握手期间设置的，TCP发送时，会在发送缓存中取出数据，传递给网络层
- 2.接收缓存：同样是三次握手期间设置的，接收方的应用程序在接收缓存中读取数据流（TCP连接的每一段都有`各自的`接收和发送缓存）
- 3.最大报文长度（Maximum Segment Size MSS）：TCP可以`从缓存中取出并放入报文段`的最大数据量，而MSS的确定通常由本地发送主机的最大链路层帧长度（或最大传输单元 Maximum Transmission Unit `MTU`）来设置

TCP连接的组成在端主机上包括`缓存`、`变量`和`套接字`

### TCP报文段结构

TCP报文段包含首部和数据字段，其中首部一般是`20字节`，它包含以下几个部分：

- 1.源端口号（16位）
- 2.目的端口号（16位）
- 3.检验和（16位）
- 4.序号（32位）
- 5.确认号（32位）
- 6.接收窗口（16位），用于指示接收方愿意接收的字节数量
- 7.首部长度（4位），指示了以`32位的字`为单位的TCP首部长度
- 8.标志字段（6位），包含一些标志位ACK（应答）；RST、SYN、FIN（用于连接建立和拆除）、CWR、ECE（用于明确拥塞通告）、PSH（指示接收方将数据交付上层）、URG（指示发送端的`被上层指示为紧急`的数据） 标志字段和首部长度字段有一些保留位，它们三个`合在一起有16位`
- 9.紧急数据指针字段（16位
- 10.选项字段（可选并可变长），用作发送方与接收方协商最大报文长度时，或在高速网络环境下用作窗口调节因子，`通常为空`

实践中PSH、URG和紧急数据指针`没有使用`

#### 序号和确认号

TCP将数据看作一个无结构的、有序的`字节流`，而一个报文段的序号是该报文段`首字节的字节流编号`

比如一个5000字节的文件，MSS为100字节，TCP会为该数据流创建50个报文段，第一个报文段分配序号0，第二个分配序号100，以此类推。每一个序号被填入到对应TCP报文段首部的序号字段中

而对于确认号来说，主机A填充进报文段的确认号是主机A`期望从主机B接收到的下一字节`的序号

假设主机A已经接收到主机B的编号为0-100的所有字节，那它向主机B发送的下一个报文段中确认号就是101

事实上，TCP连接的双方可以`随机的选择初始序号`，不必为0

#### 往返时间的估计与超时

报文段的样本RTT（SampleRTT）表示从某段报文段被发出到对该报文段的确认收到（一个来回）之间的时间

在任意时刻，只为一个`已发送但未被确认`的报文段估计SampleRTT

为使SampleRTT具有代表性，TCP维持一个SampleRTT均值（EstimatedRTT），它是加权平均算得的，计算公式为：

```
EstimatedRTT = (1-α)*EstimatedRTT + α*SampleRTT
```

官方给出的α推荐值为`0.125`

这种加权平均方法被称为`指数加权移动平均`（Exponential Weighted Moving Average EWMA）对最近的样本赋予的权值要`大于`对旧样本赋予的权值

同时还给出了RTT偏差（DevRTT）用于估算SampleRTT一般会偏离EstimatedRTT的程度，它的计算公式为：

```
DevRTT = (1-β)*DevRTT + β*|SampleRTT - EstimatedRTT|
```

β的推荐值为`0.25`

根据上面的一些概念，可以设定重传超时间隔的算法：

```
TimeoutInterval = EstimatedRTT + 4*DevRTT
```

TimeoutInterval的初始推荐值为`1秒`，当出现超时后，TimeoutInterval会`加倍`，当后续的传输受到EstimatedRTT后，将使用公式计算TimeoutInterval

### TCP的可靠数据传输

TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据是`无损坏`、`无间隙`、`非冗余`和`按序`的数据流

TCP发送方有三个主要的事件：接收上层数据、定时器超时和接收ACK

- 1.接收到上层数据时如果定时器没有运行就启动定时器，并将数据包装后发给IP
- 2.如果发生定时器超时，就重传引起超时的报文段，然后`重启定时器`
- 3.收到ACK，将ACK包含的序号（y）与自身的状态变量中保存的序号（SendBase 最早未被确认的字节序号）进行比较，如果y > SendBase，证明y之前所有的数据（包括SendBase）都已经被确认，发送方需要更新SendBase变量。如果发送方有未确认的报文段，则还需`重启定时器`

#### 超时间隔加倍

TCP重传既有最小序号的还未被确认的报文段，但是每次重传时都会将下一次的超时间隔设置为先前值的`两倍`，而不是使用EstimatedRTT和DevRTT计算出的值

这种情况会一直持续到`收到上层应用的数据`或`收到ACK`时，此时TimeoutInterval将由最近的EstimatedRTT和DevRTT计算得出

#### 快速重传

假如TCP的接收方收到了一个序号`大于`下一个所期望的、按序的报文段，这意味着有中间的数据丢失，此时TCP将返回对`最后一个按序字节数据的重复确认`，这称为`冗余ACK`

当TCP接收方接收到对相同数据的`三个冗余ACK`，就说明这个ACK对应的报文段之后的报文段已经丢失，此时TCP将执行`快速重传`，即在该报文段的`定时器过期之前`重传丢失的报文段

#### 回退N步+选择重传

TCP的差错恢复机制相当于GBN和SR的混合

### 流量控制

在接收方数据先被放入`接收缓存`中，然后应用程序从接收缓存读取数据，如果应用程序读取的速度小于发送方的发送速度，则会引起`缓存溢出`

为了解决这个问题，TCP提供了`流量控制服务`，它是一个`速度匹配`服务，即将发送方的发送速度与接收方应用程序的读取速度相匹配

（区别于`拥塞控制`：拥塞控制指的是TCP发送方因为`IP网络`的拥塞而被遏制）

TCP通过让`发送方`维护一个称为`接收窗口`的变量来提供流量控制，它的作用是告诉发送方接收方还有多少可用的缓存空间

定义变量：

- LastByteRead：接收方的应用进程从`接收缓存读出`的数据流的`最后一个字节`编号
- LastByteRcvd：已经`放入接收方接收缓存`的数据流的`最后一个字节`编号
- RcvBuffer：接收缓存长度

因为接收缓存不许溢出，则下式必须成立

```
LastByteRcvd - LastByteRead <= RcvBuffer
```

则接收窗口rwnd为：

```
rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
```

接收方将当前rwnd放入报文段的`接收窗口字段`中，来告诉发送方自己还有多少缓存空间可用

在发送方也有两个变量：

- LastByteSend：最后发送出的字节编号
- LastByteAcked：最后被确认的字节编号

`LastByteSend - LastByteAcked`则表示已发出但未被确认的数据量，需要将它控制在rwnd之内，即：

```
LastByteSend - LastByteAcked <= rwnd
```

- 注意在接收窗口为0时，为`防止发送方被拥塞`，发送方需要继续发送只有`一个字节`数据的报文段（因为接收方只能在返回响应的时候才能将新的接收窗口告诉发送方）

### TCP连接管理

#### 连接的建立（三次握手）

- 1.客户向服务器发送一个不包含数据的报文段，其中的`SYN标志位置1`，并且随机生成一个`初始序号`（client_isn），放置于报文段的`序号字段`中。这个特殊报文段被称为`SYN报文段`

- 2.服务器收到TCP SYN报文段，为该TCP连接分配缓存和变量（这容易收到SYN洪泛攻击，后面会讨论），并向客户返回一个`允许连接`的报文段，这个报文段包含三个重要的信息：`SYN置1`、`确认号字段为client_isn + 1`以及服务器生成自己的`初始序号（server_isn）放在序号字段中`。该报文段称为`SYNACK报文段`

- 3.客户收到SYNACK报文段后，为TCP连接分配缓存和变量，并向服务器发送一个`确认报文段`，其`确认号`字段设置为`server_isn + 1`，因为此时连接已经建立，`SYN被置为0`，并且此次传输可以`发送数据`

如果服务器上的某端口未开启，则向客户发送一个特殊重置报文段，其中`RST标志位置1`，来告诉客户当前请求的服务未开启

#### 连接的终止

TCP连接的`任意一方`都可以终止连接，以客户终止为例：

- 1.客户应用进程发送一个关闭连接命令，使得客户的TCP向服务器发送一个特殊的TCP报文段，其中首部的`FIN标志位置1`

- 2.服务器收到报文段后，先向发送方返回一个`确认报文段`；然后服务器发送自己的`终止报文段`，其中的`FIN置1`（注意发送了两次）

- 3.客户对服务器的终止报文段返回一个`确认`，此时连接终止

#### SYN洪泛攻击

SYN洪泛攻击指的是攻击者发送大量的TCP SYN报文段（第一次握手），却`不完成对服务器的确认`（第三次握手），由于服务器在第二次握手的时候就分配了资源，这将使得服务器的资源被消耗殆尽

解决办法是使用`SYN cookie`技术：服务器接收到SYN报文段时，暂时不会分配资源，而是针对该报文段的源、目的IP地址与端口号生成一个`初始TCP序列号`，称为cookie，并将它返回给客户，客户发送确认信息时将包含这个cookie，从而验证该用户是一个合法用户

