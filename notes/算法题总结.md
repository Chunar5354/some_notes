# 1.使用数组中的元素值计算数组下标更新数组元素

常见于题目中给出类似：`数组长度为n，数组所有元素x满足：0<x<=n<=1000`，也就是数组元素的值小于数组长度，这样所有的数组下标都可以由数组元素表示

## 例题1

> 给定一个数组，数组长度为n,数组所有元素x满足：0<x<=n<=1000。求数组中出现次数最多的元素，若多个元素出现次数相同，输出元素值较大的，要求时间复杂度O(n),空间O(1)

```python
arr = [1,3,2,1,5,6,1,2,5,4,8,5,1]
n = len(arr)
p = 1 << 16
# 让每个位置i存储的是p的m倍，表示数字i出现了m次
for i in range(n):
    x = arr[i] % p
    arr[x] += p
    arr[i] -= x

MAX = 0
ans = 0
for i in range(n):
    print("数字",i,"在数组中出现的次数：",arr[i]//p)
    if MAX <= arr[i]//p:
        MAX = arr[i]//p
        ans = i
print("出现次数最多的数字",ans)
```

## 例题2

> 找出小于n的所有质数

质数没有除了1和它本身的约数，所以对于每一个数字x，`x*(x+m)`(m从0开始且最终要小于n)都不是质数

```python
def Sieve(n):
    if n == None or n <= 1:
        return
    temp = [0]*(n+1)
    for p in range(2, len(temp)):
        temp[p] = p
    for p in range(2, int(n**0.5)+1):
        if temp[p] != 0:
            j = p * p
            # 将不是质数的数字置为0
            while j <= n:
                temp[j] = 0
                j += p

    output = []
    for i in temp:
        if i != 0:
            output.append(i)
    return output

print(Sieve(29))
```


# 2.递归

## 例题1 全排列

> 给定一个数组，找到它的全排列

将复杂的问题简单化的思想，每次在数组里面拿出一个数。得到剩余的数的全排列之后，将拿出去的数字放到剩余全排列的前面

```python
def permute1(seq):
    if not seq:
        return [seq]
    else:
        res = []
        for i in range(len(seq)):
            rest = seq[:i] + seq[i+1:]  # 拿出一个数
            for x in permute1(rest):  # 剩余数字的全排列
                res.append([seq[i]] + x)
        return res

a = permute1([1, 2, 3, 4])
print(a)
```

## 例题2 皇后问题

[Leetcode 51](https://leetcode.com/problems/n-queens/)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res_list = []
        
        def judge(r, c, p):  # 判断是否在同一列或对角线上（因为l决定了不可能在同一行）
            for pos in p:
                if pos[1] == c or abs(pos[0]-r) == abs(pos[1]-c):
                    return False
            return True
        
        def traceback(l, position):  # position中是所有皇后的位置
            # Now we make result string here
            # 只有符合条件的布置方式才能走到l=n这一步，此时position中就是全部皇后的位置，按照题目生成相应的结果
            if l == n:
                res = []
                for p in position:
                    current_line = ['.']*n
                    current_line[p[1]] = 'Q'
                    current_line = ''.join(current_line)
                    res.append(current_line)
                return res_list.append(res)

            # And we just deal with position here
            for i in range(n):
                if judge(l, i, position):
                    traceback(l+1, position+[[l, i]])
        
        traceback(0, [])
        return res_list
```

## 例题3 猜数字（进阶）

[leetcode 375](https://leetcode.com/problems/guess-number-higher-or-lower-ii/)

> 给定一个范围，每次会得到“大”或者“小”两种答案，但是每次猜不中都会花掉等同于数字大小的钱。问对于给定的范围n，至少需要多少钱就可以保证所有的数字都能猜到

依然是分割为`大于当前数`和`小于当前数`两个部分，不过这里使用了一个2维的cache用来存储已经搜索过的情况

```python
class Solution:
    def getMoneyAmount(self, n):
        cache = [[0]*(n+1) for _ in range(n)]
        def guess(lo, hi):
            if lo >= hi:  # 相等时意味着已经猜中，花费为0
                return 0
            if cache[lo][hi] > 0:
                return cache[lo][hi]
            ret = float('inf')
            for i in range((lo+hi)//2, hi):
                # 总花费等于猜比当前数字小的数花费的钱 + 当前数字的钱 + 猜比当前数字大的数话费的钱
                t = i + max(guess(lo, i-1), guess(i+1, hi))
                ret = min(ret, t)
                
            cache[lo][hi] = ret
            return ret
        res = guess(1, n)
        return res
```
