# MySQL架构

MySQL架构的设计将`查询处理`、`其他系统任务`以及`数据的存储/提取`相分离

## MySQL逻辑架构

MySQL的服务器端有`三层逻辑架构`，最上层处理与客户端的连接，第二层是MySQL的核心功能，包括查询解析、分析、优化、缓存以及所有的内置函数，第三层是存储引擎，负责数据的存储和提取

每个客户端连接都在服务器进程中拥有一个`线程`，在5.5版本之后支持`线程池`插件，用池中的少量线程来服务大量的连接


## 并发控制

MySQL有两个层面的并发控制：服务器层与存储引擎层

### 读写锁

`共享锁-读锁`，`排他锁-写锁`

### 锁粒度

因为加锁需要额外的开销，所以要执行`锁策略`，在开销和数据的安全性之间做权衡

两种最重要的锁策略是`表锁`和`行级锁`

- 表锁

表锁是开销最小的策略，它会锁定`整张表`，而且写锁比读锁有更高的优先级

- 行级锁

行级锁能够最大程度地支持并发处理，但同时开销也最大

行级锁只在`存储引擎层`实现

## 事务

事务是`一组原子性的SQL查询`，只有能够成功执行全部的一组查询语句，这一组语句才会执行，只要有任何一条语句不能执行，那么所有的语句都不会执行

### ACID

`ACID`：原子性(automicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)

- 原子性

一个事务被视为不可分割的最小工作单元，整个事务中的所有操作要么全部成功提交(Commit)， 要么全部回滚(Rollback)

- 一致性

数据库总是从一个一致的状态转移到另一个一致的状态，因为如果事务没有提交，事务中所做的修改也不会保存到数据库中

- 隔离性

通常一个事务所做的修改在最终提交之前，对其他事务是不可见的

- 持久性

一旦事务提交，所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失

### 隔离级别

SQL标准定义了四个隔离级别，它们各自规定了一个事务中所做的修改，那些在事务内和事务间是可见的，哪些是不可见的

较低级别的隔离通常可以执行`更高的并发`，系统的开销也更低

- READ UNCOMMITTED 未提交读

READ UNCOMMITTED中，事务中的修改，即使没有提交，对其他事务也都是`可见的`，事务读取未提交的数据称为`脏读`

- READ COMMITTED 提交读

在READ COMMITTED级别，事务从开始到提交之前，所做的任何修改对其他事务是`不可见的`

READ COMMITTED级别也成为`不可重复读`，因为执行两次同样的查询，可能得到不一样的结果

大多数数据库默认的隔离级别都是READ COMMITTED（但MySQL不是）

- REPEATABLE READ 可重复读

REPEATABLE READ解决了脏读的问题，它保证在同一个事务中多次读取同一个记录的结果是`一致的`

但REPEATABLE READ无法解决`幻读`的问题，幻读指的是某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当第一个事务再次读取的时候，就会产生`幻行`（幻读可以通过MVCC的办法解决）

MySQL的`默认隔离级别`是REPAETABLE READ

- SERIALIZABLE 可串行化

SERIALIZABLE是最高的隔离级别，它强制事务`串行`执行（读取时加锁）

### 死锁

死锁指的是两个或多个事务在`同一资源`上互相占用，并请求锁定`对方占用的资源`，从而导致恶性循环

数据库会设置死锁检测和超时机制来解决死锁问题，InnoDB目前的方法是：`将持有最少行级排他锁的事务回滚`

死锁的产生可能有两种原因：真正的数据冲突或存储引擎的实现方式不当

发生死锁时，只有完全或部分回滚其中一个事务，才能打破死锁

### 事务日志

使用事务日志，存储引擎在修改数据是只需要修改其`内存拷贝`，再将`修改行为记录`保存到硬盘上的事务日志中，而不需要每次将修改的数据本身保存到硬盘

当事务日志被保存之后，内存中被修改的数据可以在`后台`慢慢刷回到磁盘

### MySQL中的事务

MySQL有两种事务型引擎：InnoDB和NDB Cluster

MySQL默认采用`自动提交(AUTOCOMMIT)`模式，如果不显式地开始一个事务，每个操作都会被当成一个事务来执行提交操作

MySQL中可以通过:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

来设置隔离级别，新的设置将在下一个事务开始生效

InnoDB采用两阶段锁定协议，事务过程中随时可以执行锁定，锁只有在执行`COMMIT`或`ROLLBACK`的时候才会释放，并且所有的锁在`同一时刻释放`

## 多版本并发控制 MVCC

可以认为MVCC是行级锁的变种，但它能在很多时候避免加锁操作，因此开销更低

MVCC是通过保存数据在某个时间点的`快照`来实现的，所以每个事务看到的数据取决于`事务开始的时间`，不同开始时间的事务在同一时刻可能看到的数据是不一样的

典型的MCVV有`乐观`并发控制和`悲观`并发控制

InnoDB的并发控制是通过在每行记录后面保存`两个隐藏的列`来实现的，两个列一个保存行的`创建时间`，一个保存`过期时间`，而且存储的不是实际的时间值，而是`系统版本号`

没开始一个新事务，系统版本号会`自动递增`，事务`开始时刻`的系统版本号作为`事务的版本号`

SELECT操作只会查找版本`早于当前事务版本`的数据行，此时改行的删除版本（过期时间）要么未定义，要么大于当前事务版本，这样使得大多数的读操作`不需要加锁`

MVCC只在`REPAEATABLE READ`和`READ COMMITTED`两个隔离级别下工作，另两个级别和MVCC不兼容

## MySQL的存储引擎

MySQL将每个数据库（schema）保存为文件系统中数据目录下的一个字目录（CentOS系统中存储在`/var/lib/mysql`）

每当创建一个表，将在数据库子目录中创建一个同名的`.frm`文件，用来储存`表的定义`，表中的数据存储在一个同名的`.ibd`文件中

### InnoDB

InnoDB是5.1版本之后的`默认存储引擎`，它被设计来处理`大量的短期事务`，它们大部分是正常提交的，很少会被回滚

InnoDB的数据存储在`表空间`中，它是一个由一系列数据文件组成的黑盒子

InnoDB采用MVCC来支持高并发，默认隔离级别是REPEATABLE READ，并且使用`间隙锁`(不只锁定查询涉及的行，还对索引中的间隙进行锁定，以防止幻行)

InnoDB表是基于`聚簇索引`建立的，它对于主键查询有很高的性能，但它的二级索引中必须`包含主键列`，所以主键的长度影响着所有索引的长度

InnoDB支持`热备份`，而其他存储引擎是不支持的

### MyISAM

MyISAM是5.1版本之前的默认存储引擎，它不支持`事务`和`行级锁`，但具有一些特性如全文索引、压缩和空间函数等

MyISAM对于较小的表、只读数据、能够忍受修复操作的场景应用较多，它的数据在崩溃后`无法安全恢复`

MyISAM将表存储在两个文件中：数据文件`.MYD`和索引文件`.MYI`

MyISAM对`整张表`进行加锁

# 基准测试

通过基准测试能够测试数据库或应用系统在给定应用场景下的实用性能，也可以找出系统存在的问题，是很有用的工具

主要介绍一种测试工具`sysbench`

## 安装sysbench

- 1.下载安装包并解压：

```
# wget https://github.com/akopytov/sysbench/archive/1.0.zip -O "sysbench-1.0.zip"
# unzip sysbench-1.0.zip
# cd sysbench-1.0
```

- 2.安装依赖

```
yum install automake libtool, kernel-headers –y
```

- 3.编译

```
./autogen.sh
./configure
export LD_LIBRARY_PATH=/usr/local/mysql/include #这里换成机器中mysql路径下的include
make
make install
```

- 4.测试是否安装成功

```
sysbench --version
```

关于测试应用参考书上P55

# 服务器性能剖析

通过性能剖析可以找到开销最大的任务，从而针对性的进行优化

将性能定义为完成某件任务所需要的时间度量，即`响应时间`，性能的优化就是在一定的负载下尽可能地降低响应时间

## MySQL剖析

对MySQL进行性能剖析很有用的工具是`慢查询日志`

### 剖析单条查询

- 1.使用SHOW PROFILE

首先启用PROFILE

```sql
SET profiling = 1;
```

执行任意查询语句后，使用

```sql
SHOW PROFILES;
```

它会为查询语句编号，并给出执行时间

也可以使用

```sql
SHOW PROFILE FOR QUERY 1;
```

它会给出执行该条查询语句时，执行的每一个步骤及其所需的时间

其中编号1是SHOW PROFILES时给出的Query_ID

- 2.使用SHOW STATUS

`SHOW (GLOBAL) STATUS`命令可以给出数据库的统计信息（通过计数器实现），比如客户端连接数，读写频率等

- 3.使用慢查询日志

通常慢查询是默认关闭的，可以使用

```sql
SHOW VARIABLES LIKE "%slow_query_log%";
```

来查看

然后使用

```sql
SET GLOBAL slow_query_log=1;
SET GLOBAL slow_query_log_file="your/own/path";
```

来分别设置开启慢查询日志和日志文件存放位置（CentOS系统日志默认存放位置是`/var/lib/mysql/hostname-slow.log`）

同时还需要设置慢查询时间`long_query_time`（默认是10s）

```sql
SET GLOBAL long_query_time=1;
```

注意这种方式只是临时设置，重启MySQL之后会丢失，想要永久设置需要编辑my.cnf文件，添加下面的内容后重启MySQL

```
[mysqld]
slow_query_log='ON'
low_query_log_file="your/own/path"
long_query_time=1
```

执行一个延时语句来测试（只要超过设置的long_query_time就会被记录）

```sql
SELECT SLEEP(3);
```

然后就可以查看日志文件中记录的内容

# Schema与数据类型优化

## MySQL中的数据类型

### 整数类型

MySQL有两种类型的数字：`整数`和`实数`

整数有以下几种类型：TINYINT(8位), SMALLINT(16位), MEDIUMINT(24位), INT(32位), BIGINT(64位)

也可以使用`UNSIGNED`指定为无符号整数，表示不允许负值

为整数类型指定宽度，如INT(11)，只是规定了`显式`字符的个数，在内部的存储和计算来说没有意义，INT(1)和INT(20)时相同的

### 实数类型

实数是带有小数部分的数字

其中FLOAT(4字节)和DOUBLE(8字节)支持用标准定浮点运算进行`近似计算`，DECIMAL类型用于存储`精确`的小数

由于CPU不支持DECIMAL的直接计算，MySQL服务器`自身实现`了DECIMAL的高精度计算，所以CPU自身支持的原生浮点计算会更快

MySQL将数字打包保存到一个`二进制字符串`中，每4个字节存9个数字，如DECIMAL(18, 9)将小数点两边的9个数字各使用4字节存储，小数点本身用一个字节存储，一共9个字节

DECIMAL类型最多存储65个数字，而且DECIMAL只是一种`存储格式`，计算式会转换为`DOUBLE类型`

### 字符串类型

字符串类型主要有VARCHAR和CHAR两种

- VARCHAR

VARCHAR是变长字符串，使用1或2个额外字节记录`字符串的长度`，它比定长类型更节省空间

- CHAR

CHAR是定长字符串，MySQL会根据定义的字符串长度分配存储空间，并`删除末尾空格`

### BLOB和TEXT类型

BLOB和TEXT分别是为存储二进制和字符`大数据`而设计的`字符串数据类型`

分别包括：TINYTEXT(BLOB), SMALLTEXT(BLOB), TEXT(BLOB), MEDIUMTEXT(BLOB), LONGTEXT(BLOB)

MySQL将BLOB和TEXT当作独立的对象处理，并且当BLOB和TEXT值太大时，InnoDB使用专门的`外部存储区域`来存储

### 枚举ENUM类型

可以使用枚举列把常用的不重复字符串存储成一个预定义的`集合`

如

```sql
CREATE TABLE enum_test(e ENUM('fish', 'apple', 'dog') NOT NULL);
```

创建了一个包含枚举列e的表enum_test，枚举列中`只能`插入定义的集合中的元素，否则会报错

并且e这一列中存储的是表示元素位置的整数，而在表的.frm文件中保存`数字-字符串`的映射关系

执行下面的语句：

```sql
INSERT INTO enum_test(e) VALUES('dog');
SELECT e FROM enum_test;
SELECT e+0 FROM enum_test;
```

第一条查询语句得到的结果是'dog'，而第二条语句得到的结果是3

### 时间类型

MySQL支持的最小时间粒度为`秒`，MariaDB支持微秒级别的时间类型

MySQL提供两种相似的日期类型：`DATETIME`和`TIMESTAMP`

- DATETIME

DATETIME格式将时间封装到格式为`YYYYMMDDHHMMSS`的整数中，与时区无关

- TIMESTAMP

使用`4字节`表示UNIX时间戳，只能表示1970年到2038年，它显示的值依赖于时区

### 位数据类型

- BIT

BIT类型在一列中存储一个或多个true/false值，`BIT(n)`指定包含n个位

MySQL将BIT当作`字符串类型`，但在数字上下文中检索时，得到的结果却是位字符串转换成的`数字`

比如一个值为b'00111001'，直接检索它得到的是`字符码为57的字符串'9'`，而在数字上下文中得到的就是数字57

- SET

SET是一系列打包的`位的集合`

## 范式与反范式

使用范式可以更好的减少重复数据，而且更新更快，但缺点是通常需要大量的`关联`

在实际应用中，通常需要结合范式与反范式，最常见的反范式化是`复制或缓存`，在不同的表中存储相同的特定列

只需要在缓存表中复制有用的列，这样就不会使得缓存表太大，而在进行查询操作时可以直接通过缓存表中的数据进行排序等复杂的操作，省去了关联表的开销

### 缓存表，汇总表和计数器表

在其他的表中保存衍生的冗余数据可以提高查询性能，常用的方法有三种：

- 缓存表

存储那些可以比较简单地从schema其他表获取数据的表

- 汇总表

保存使用GROUP BY语句聚合数据的表

- 计数器表

为某些事件（比如用户点击次数）计数

如果想要提高并发性，可以在计数器表中增加一个slot字段，并将计数器保存在`多行`中，每次根据slot的值`随机增加一个计数器`，在需要统计的时候去查询所有计数器行的`和`

## ALTER TABLE的优化

通常MySQL执行ALTER TABLE操作都方法是用新的结构创建一个空表，将旧表的数据插入信标，再删除旧表，但这样对空间和时间的消耗都比较大

通常ALTER TABLE会导致MySQL中断，可以使用`影子拷贝`技巧：先创建一个和源表五滚动信标，再通过`重命名`的方法交换两张表，这样就不会导致中断

或者可以只修改描述表结构的`.frm`文件，因为不涉及表数据，所以这种操作也比较快

# 创建高性能的索引

索引（key，键）是`存储引擎`用于快速找到记录的一种`数据结构`

## 索引类型

### B-Tree索引

大多数MySQL引擎都支持B-Tree索引（InnoDB使用的是B+Tree）

在B-Tree中，所有的值都是按`顺序`存储的，每一个节点表示`页`，每一个叶子页到根的距离都`相同`

使用B-Tree，存储引擎只需要从索引的根节点出发，根据节点槽中指向子节点的`指针`进行搜索，通过比较节点页的值和目标值可以找到合适的指针进入下一层，这些指针实际上定义了子节点页中值的`上界和下界`，最终要么找到目标值，要么目标值不存在

与其他节点不同，叶子节点指向的是`被索引的数据`，而不是其它节点页

因为B-Tree是按顺序组织的，所以很适合查找`范围数据`

B-Tree适用于`全键值`、`键值范围`或`键前缀`查找，具体包括以下几种：

- 全值匹配：匹配索引中的所有列

- 匹配最左前缀：只匹配索引的第一列

- 匹配列前缀：只匹配某一列的开头部分

- 匹配范围值：匹配某一列中在某个范围内的值

- 精确匹配某一列并范围匹配另一列

- 只查询索引列

### 哈希索引

对于每一行数据，存储引擎都会对`所有的索引列`计算一个哈希码，然后将所有的哈希码存储在索引中，同时在`哈希表`中保存指向每个数据行的指针

MySQL中只有Memory引擎支持哈希索引

InnoDB会为使用频率较高的索引值自动建立哈希索引，称为`自适应哈希索引`

### 空间数据索引 R-Tree

利用所有维度来组合查询

## 索引的优点

- 1.大大减少服务器需要扫描的数据量

- 2.帮助服务器避免排序和临时表

- 3.可以将随机I/O变为顺序I/O

## 高性能索引

### 1.独立的列

索引列不能包含在表达式中

### 2.前缀索引

有时索引列是很长的字符串，这时可以索引`开始的部分字符`，这样能够大大节约索引空间

不过这样会降低索引的`选择性`（不重复的索引值和数据表记录总数的比值），所以要在前缀长度和选择性之间做好平衡

创建前缀索引：

```sql
ALTER TABLE pre_test ADD KEY index(5);
```

上面的语句指定index列的前5个字符作为索引

MySQL在使用前缀索引时，无法ORDER BY和GROUP BY

### 3.多列索引

当需要多个列的数据共同进行索引的时候，最好将几个列共同定义为索引，如`KEY(c1, c2, c3)`，而不要分别定义索引再使用AND或OR操作符来联结

多列索引中如果有某一个索引列应用了`范围查询`，那么索引将到这一列为止，后面的列都不能使用索引了

### 4.合适的索引列顺序

再B-Tree中，如果是多列索引的话，索引首先按照`最左列`进行排序，然后依次向右，所以合理的安排索引列顺序能够加快ORDER BY等子句的性能

通常可以将`选择性最高`的列放在索引最前列

### 5.聚簇索引

聚簇索引指的是一种`数据存储方式`

在聚簇索引中，数据行存放在索引的`叶子页`中，一个表`只能有一个`聚簇索引

在InnoDB的聚簇索引中，叶子页包含了全部数据，节点页只包含`索引列`

MySQL中的引擎`不支持主动选择`哪个索引作为聚簇索引，InnoDB会将`主键列`作为聚簇索引，如果没有主键列，则会选一个`唯一的非空索`引代替，如果也没有这样的索引，InnoDB就会隐式地定义一个主键来作为聚簇索引

聚簇索引的优点：

- 1.将相关数据保存在一起，从磁盘读取少量的数据页就能获得全部信息

- 2.索引和数据行保存在同一个B-Tree中，所以速度更快

- 3.可以直接使用页节点中的主键值来进行`覆盖索引扫描`的查询

聚簇索引的缺点：

- 1.聚簇索引提高到是`I/O密集型应用`的性能，如果数据本身就存放在内存中，访问的顺序就不重要了

- 2.数据插入速度非常依赖插入顺序

- 3.因为每次都要要排序，所以更新聚簇索引列的代价很高

- 4.插入新行时可能导致`页分裂`问题

- 5.可能导致全表扫描变慢

- 6.因为二级索引（非主键，二级索引的叶子节点中存储的是`主键值`）会包含主键值，所以聚簇索引可能会导致二级索引变得很大


在MyISAM中，主键索引和其它索引没有区别，只是名为PRIMARY

但在InnoDB中，由于主键索引就是聚簇索引，每一个叶子页中会包含对应行的`全部数据`

尽量使用有顺序的`主键列`，这样插入时会简单地将新行插入到索引的最后，可以避免页分裂

### 6.覆盖索引

如果索引`包含`有所需要查询的字段的值，就称之为覆盖索引，这样在查询时就只需要扫描索引而不用访问源表

覆盖索引必须存储索引列的值，而哈希索引、空间索引与全文索引都不存储索引列的值，所以MySQL中只有B-Tree可以做覆盖索引

### 7.使用索引扫描做排序

除了通过排序操作，MySQL也可以使用索引扫描进行排序，但这要求索引的`列顺序`和ORDER BY子句的顺序完全一致，并且所有列的`排序方式都一样`（全部升序或全部降序），而且需要满足`最左前缀`的要求，进行关联查询时，还要求ORDER BY子句引用的字段全为`第一个表`才可以

### 8.前缀压缩索引

`MyISAM`中可以使用前缀压缩的方式来减少索引的大小，默认是压缩`字符串`，也可以设置为压缩整数

具体方法是：完全保存索引块的第一个值，然后将后面的每一个值与第一个值进行比较，得到相同前缀的`字节数`以及`剩余部分`，比如第一个值是abcd，第二个值是abcdef，则第二个值保存为"4, ef"的形式

### 9.重复和冗余索引

重复索引指的是在相同的列上按照相同的顺序创建相同类型的索引，应该尽量避免

冗余索引：如果有一个(A, B)索引，再创建一个A索引，那A就是冗余索引，因为A是(A, B)的前缀索引，而单独创建B索引则不是冗余索引

冗余索引有时能够加快某些查询的性能，但会降低插入性能，也应该尽量避免

### 10.索引与锁

使用索引可以减少要查询的行，从而减少对行的锁定，能够提高并发性

索引要尽可能过滤掉无效的行，否则检索到数据并发送到`服务器层`之后，MySQL才能使用WHERE子句，这就无法避免锁定行了

InnoDB中，`二级索引`使用共享锁，`主键索引`使用排他锁

## 维护索引和表

维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息和减少碎片

### 找到并修复损坏的表

可以使用`CHECK TABLE`来检查表是否损坏，并使用`REPAIR TABLE`来修复损坏的表(MyISAM)，但有些存储引擎不支持这个名令，此时可以通过一个不做任何操作的ALTER来修复，如：

```sql
ALTER TABLE innodb_tbl ENGINE=INNODB;
```

### 更新索引统计信息

MySQL的查询优化器通过records_in_range()和info()两个API来获取索引统计信息，并可以根据索引统计信息来估算`扫描行数`

可以使用`ANALYZE TABLE`来重新生成统计信息

使用`SHOW INDEX FROM`来查看表中索引的`基数`(Cardinality，它表示存储引擎估算索引列有多少个不同的取值)

### 减少索引和数据的碎片

B-Tree索引可能会碎片化（因为要按顺序），有三种类型的碎片：

- 行碎片：数据行被存储在多个地方的多个碎片中

- 行间碎片：`逻辑上是顺序`的行或页在磁盘上不按顺序存储

- 剩余空间碎片：数据页中含有大量的空余空间，这会导致服务器读取大量不需要的数据

MyISAM表中三种碎片都有可能发生，而InnoDB表中不会发生小的行碎片

可以使用`OPTIMIZE TABLE`或导出再导入的方法来重新整理数据，再InnoDB中可以通过先删除、再重新创建索引的方法来`消除索引碎片化`

对于不支持POTIMIZE TABLE的存储引擎，也可以使用`ALTER TABLE`空操作来消除碎片

- 总结：要尽量`避免单行查询`、尽可能使用`数据原生顺序`而避免额外的排序、尽量使用`覆盖索引`

# 查询性能优化

将查询看作一个任务，它由一系列子任务组成，优化查询实际上就是优化子任务，要么`消除`一些子任务，要么`减少`子任务的执行次数

## 优化数据访问

大部分性能低下的查询都可以通过`减少访问的数据量`的方式来进行优化

MySQL会默认返回全部结果集到客户端，可以通过LIMIT关键字来减少数据行

衡量查询开销有三个指标：响应时间、扫描的行数和返回的行数，他们都可以在慢查询日志中找到

### 响应时间

响应时间是`服务时间`和`排队时间`之和，服务时间指的是数据库处理查询的真正时间，排队时间指的是服务器因为等待某些资源花掉的时间，如等待IO操作或等待行锁等

### 扫描行数和返回行数

扫描行数与返回行数的比例能表征查询的`效率`，理想情况下它们应该相等，但实际上一般在1:1到1:10之间

### 访问类型

可以通过`EXPLAIN`语句来查看查询语句的访问类型

MySQL能用以下3种方式应用WHERE子句，从好到坏依次为：

- 1.在`索引`中使用WHERE条件来过滤记录，这是在`存储引擎层`完成的

- 2.使用`索引扫描覆盖`（EXPLAIN的Extra中出现`Using index`）返回记录，在索引中过滤，这是在`服务器层`完成的，但`无需再回表`进行查询

- 3.从`数据表`中返回数据，然后再过滤不满足条件的记录（Extra中出现`Using where`），这在`服务器层`完成，并需要先从`数据表`中读取记录然后过滤

## 重构查询方式

通常将一个大查询切分成许多个小查询可以提高性能，因为大查询通常会一次性锁定很多数据，阻塞其它的查询，比如删除一百万行数据可以分成一百次删除一万行数据来执行

将许多个表的关联查询分解成多个对单独表的简单查询也能够提高性能，它有以下几方面的优势：

- 1.让缓存的效率更高，关联查询中如果某个表发生了变动，那么整个查询都不能使用缓存，但拆分之后未改动的表就仍然可以使用缓存

- 2.单个查询可以减少锁的竞争

- 3.将数据在应用层做关联可以提高扩展性


## 查询执行方式

MySQL执行一条查询需要经过以下步骤：

- 1.客户端发送一条查询给服务器

- 2.服务器先检查`查询缓存`，如果缓存命中，则直接返回

- 3.如果缓存不命中，服务器端需要进行`SQL解析`、`预处理`，再由`优化器`生成对应的执行计划

- 4.根据`执行计划`，调用`存储引擎的API`进行查询

- 5.查询结果返回给客户端

### MySQL服务器/客户端通信协议

MySQL的服务器-客户端通信协议是`半双工`的，同一时刻只能有一方发送数据，并且在服务器推送数据的时候，客户端`不能打断`

多数连接MySQL的应用程序库函数都默认`一次获取全部结果`并`缓存`到内存中，接下来应用程序获取数据都是从库函数的缓存中获取

### 查询状态

每个MySQL连接也是一个线程，所以相应的任何时刻都有一个`状态`，使用`SHOW FULL PROCESSLIST`命令可以查看状态（Command列）

- Sleep：等待客户端发送新的请求

- Query：正在执行查询或正在将结果发送客户端

- Locked：在MySQL服务器层，线程正在等待`表锁`（行锁不会体现在线程状态中）

- Analyzing and statistics：正在收集存储引擎的统计信息，并生成查询的`执行计划`

- Copying to tmp table (on disk)：线程正在执行查询，并将结果都复制到一个临时表中(GROUP BY，UNION操作)，如果后面又on disk标记，说明正在将内存临时表放到磁盘上

- Sorting result：正在对结果集进行排序

- Sending data：可能在多个`状态之间`传送数据，或生成结果集，或在向客户端返回数据

### 查询缓存

缓存查询是通过一个`大小写敏感的哈希查找`实现的

如果缓存命中，在返回查询结果之前还会先检查一次`用户权限`

### 查询优化处理

如果缓存不命中，下一步是将SQL语句转换成执行计划，这中间包括多个子阶段：解析SQL、预处理和优化SQL执行计划

- 语法解析器和预处理

MySQL通过`关键字`解析SQL语句，并生成一棵对应的`解析树`

预处理器则会验证`解析树是否合法`，如数据表或列是否存在，或者名字是否有歧义，然后预处理器还会`验证权限`

- 查询优化器

MySQL使用基于`成本`的优化器，可以通过查询当前会话的`last_query_cost`的值来得知MySQL`计算`出的当前查询成本（返回的单位是`数据页`）：

```sql
SHOW STATUS LIKE 'last_query_cost';
```

MySQL的查询优化器使用两种类型的优化策略：

`静态优化`指的是直接对解析树进行分析，并完成优化，它不依赖参数，第一次完成后旧一直有效，是`编译时优化`

`动态优化`与查询的上下文有关，在每次查询的时候都需要重新评估，时`运行时优化`

- 统计信息

MySQL中数据和索引的统计信息由`存储引擎`实现，所以查询优化器在生成执行计划时，需要向存储引擎获取统计信息（包括表或索引的页数，索引的基数、长度等等）

- MySQL执行关联查询

MySQL认为任何一次查询都是一个`关联（JOIN）`

MySQL关联执行的策略是`嵌套循环关联`：先在一个表中循环取出单条数据，再循环嵌套到下一个表中找到`匹配的行`，依次进行直到找到所有表中匹配的行，然后根据匹配的行返回查询需要的记录

- 执行计划

MySQL为查询生成一棵`指令树`，存储引擎执行完成指令树并返回结果

- 关联查询优化器

关联查询优化决定了多个表关联时的`查询顺序`，多个表关联时会有很多种查询顺序，关联优化器会评估不同顺序时的成本来选择一个代价最小的关联顺序

可以使用`STRAIGHT_JOIN`关键字规定MySQL按照自己给出的顺序进行关联

- 排序优化

在不能通过索引进行排序的时候，MySQL需要自己进行排序，数据量小的时候在内存中进行，数据量大的时候则使用磁盘，MySQL将这个过程统称为`文件排序`

如果排序的数据量小于排序缓冲区，MySQL使用内存进行`快速排序`，如果内存不够，则先将数据`分块`，对每个块独立使用快速排序，并将各个块的结果存放在`磁盘`上，然后将排好序的块进行`合并`

MySQL有两种排序算法：

**1.两次传输排序（旧版本）**

读取行指针和`需要排序的字段`，排序后再根据排序结果读取所需的数据行

这个操作需要读取`两次`数据，且第二次数据读取的是被排序后的结果，会产生大量随机IO

优点是排序时使用尽可能少的数据，能更好的利用内存排序

**2.单次传输排序（新版本）**

读取`查询所需的所有列`，排序后`直接返回结果`

相比于两次传输排序，它只需要读取一次表，但排序时会占用更多空间

MySQL在排序时需要为每个记录分配足够的`定长空间`来存放，且在关联查询时如果ORDER BY子句中的列不是来自于第一个表，MySQL会将关联的结果存放到`临时表`中，在所有的关联都结束之后才进行排序，所以需要很大的数据空间
