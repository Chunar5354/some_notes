# MySQL架构

MySQL架构的设计将`查询处理`、`其他系统任务`以及`数据的存储/提取`相分离

## MySQL逻辑架构

MySQL的服务器端有`三层逻辑架构`，最上层处理与客户端的连接，第二层是MySQL的核心功能，包括查询解析、分析、优化、缓存以及所有的内置函数，第三层是存储引擎，负责数据的存储和提取

每个客户端连接都在服务器进程中拥有一个`线程`，在5.5版本之后支持`线程池`插件，用池中的少量线程来服务大量的连接


## 并发控制

MySQL有两个层面的并发控制：服务器层与存储引擎层

### 读写锁

`共享锁-读锁`，`排他锁-写锁`

### 锁粒度

因为加锁需要额外的开销，所以要执行`锁策略`，在开销和数据的安全性之间做权衡

两种最重要的锁策略是`表锁`和`行级锁`

- 表锁

表锁是开销最小的策略，它会锁定`整张表`，而且写锁比读锁有更高的优先级

- 行级锁

行级锁能够最大程度地支持并发处理，但同时开销也最大

行级锁只在`存储引擎层`实现

## 事务

事务是`一组原子性的SQL查询`，只有能够成功执行全部的一组查询语句，这一组语句才会执行，只要有任何一条语句不能执行，那么所有的语句都不会执行

### ACID

`ACID`：原子性(automicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)

- 原子性

一个事务被视为不可分割的最小工作单元，整个事务中的所有操作要么全部成功提交(Commit)， 要么全部回滚(Rollback)

- 一致性

数据库总是从一个一致的状态转移到另一个一致的状态，因为如果事务没有提交，事务中所做的修改也不会保存到数据库中

- 隔离性

通常一个事务所做的修改在最终提交之前，对其他事务是不可见的

- 持久性

一旦事务提交，所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失

### 隔离级别

SQL标准定义了四个隔离级别，它们各自规定了一个事务中所做的修改，那些在事务内和事务间是可见的，哪些是不可见的

较低级别的隔离通常可以执行`更高的并发`，系统的开销也更低

- READ UNCOMMITTED 未提交读

READ UNCOMMITTED中，事务中的修改，即使没有提交，对其他事务也都是`可见的`，事务读取未提交的数据称为`脏读`

- READ COMMITTED 提交读

在READ COMMITTED级别，事务从开始到提交之前，所做的任何修改对其他事务是`不可见的`

READ COMMITTED级别也成为`不可重复读`，因为执行两次同样的查询，可能得到不一样的结果

大多数数据库默认的隔离级别都是READ COMMITTED（但MySQL不是）

- REPEATABLE READ 可重复读

REPEATABLE READ解决了脏读的问题，它保证在同一个事务中多次读取同一个记录的结果是`一致的`

但REPEATABLE READ无法解决`幻读`的问题，幻读指的是某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当第一个事务再次读取的时候，就会产生`幻行`（幻读可以通过MVCC的办法解决）

MySQL的`默认隔离级别`是REPAETABLE READ

- SERIALIZABLE 可串行化

SERIALIZABLE是最高的隔离级别，它强制事务`串行`执行（读取时加锁）

### 死锁

死锁指的是两个或多个事务在`同一资源`上互相占用，并请求锁定`对方占用的资源`，从而导致恶性循环

数据库会设置死锁检测和超时机制来解决死锁问题，InnoDB目前的方法是：`将持有最少行级排他锁的事务回滚`

死锁的产生可能有两种原因：真正的数据冲突或存储引擎的实现方式不当

发生死锁时，只有完全或部分回滚其中一个事务，才能打破死锁

### 事务日志

使用事务日志，存储引擎在修改数据是只需要修改其`内存拷贝`，再将`修改行为记录`保存到硬盘上的事务日志中，而不需要每次将修改的数据本身保存到硬盘

当事务日志被保存之后，内存中被修改的数据可以在`后台`慢慢刷回到磁盘

### MySQL中的事务

MySQL有两种事务型引擎：InnoDB和NDB Cluster

MySQL默认采用`自动提交(AUTOCOMMIT)`模式，如果不显式地开始一个事务，每个操作都会被当成一个事务来执行提交操作

MySQL中可以通过:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

来设置隔离级别，新的设置将在下一个事务开始生效

InnoDB采用两阶段锁定协议，事务过程中随时可以执行锁定，锁只有在执行`COMMIT`或`ROLLBACK`的时候才会释放，并且所有的锁在`同一时刻释放`

## 多版本并发控制 MVCC

可以认为MVCC是行级锁的变种，但它能在很多时候避免加锁操作，因此开销更低

MVCC是通过保存数据在某个时间点的`快照`来实现的，所以每个事务看到的数据取决于`事务开始的时间`，不同开始时间的事务在同一时刻可能看到的数据是不一样的

典型的MCVV有`乐观`并发控制和`悲观`并发控制

InnoDB的并发控制是通过在每行记录后面保存`两个隐藏的列`来实现的，两个列一个保存行的`创建时间`，一个保存`过期时间`，而且存储的不是实际的时间值，而是`系统版本号`

没开始一个新事务，系统版本号会`自动递增`，事务`开始时刻`的系统版本号作为`事务的版本号`

SELECT操作只会查找版本`早于当前事务版本`的数据行，此时改行的删除版本（过期时间）要么未定义，要么大于当前事务版本，这样使得大多数的读操作`不需要加锁`

MVCC只在`REPAEATABLE READ`和`READ COMMITTED`两个隔离级别下工作，另两个级别和MVCC不兼容

## MySQL的存储引擎

MySQL将每个数据库（schema）保存为文件系统中数据目录下的一个字目录（CentOS系统中存储在`/var/lib/mysql`）

每当创建一个表，将在数据库子目录中创建一个同名的`.frm`文件，用来储存`表的定义`，表中的数据存储在一个同名的`.ibd`文件中

### InnoDB

InnoDB是5.1版本之后的`默认存储引擎`，它被设计来处理`大量的短期事务`，它们大部分是正常提交的，很少会被回滚

InnoDB的数据存储在`表空间`中，它是一个由一系列数据文件组成的黑盒子

InnoDB采用MVCC来支持高并发，默认隔离级别是REPEATABLE READ，并且使用`间隙锁`(不只锁定查询涉及的行，还对索引中的间隙进行锁定，以防止幻行)

InnoDB表是基于`聚簇索引`建立的，它对于主键查询有很高的性能，但它的二级索引中必须`包含主键列`，所以主键的长度影响着所有索引的长度

InnoDB支持`热备份`，而其他存储引擎是不支持的

### MyISAM

MyISAM是5.1版本之前的默认存储引擎，它不支持`事务`和`行级锁`，但具有一些特性如全文索引、压缩和空间函数等

MyISAM对于较小的表、只读数据、能够忍受修复操作的场景应用较多，它的数据在崩溃后`无法安全恢复`

MyISAM将表存储在两个文件中：数据文件`.MYD`和索引文件`.MYI`

MyISAM对`整张表`进行加锁

# 基准测试

通过基准测试能够测试数据库或应用系统在给定应用场景下的实用性能，也可以找出系统存在的问题，是很有用的工具

主要介绍一种测试工具`sysbench`

## 安装sysbench

- 1.下载安装包并解压：

```
# wget https://github.com/akopytov/sysbench/archive/1.0.zip -O "sysbench-1.0.zip"
# unzip sysbench-1.0.zip
# cd sysbench-1.0
```

- 2.安装依赖

```
yum install automake libtool, kernel-headers –y
```

- 3.编译

```
./autogen.sh
./configure
export LD_LIBRARY_PATH=/usr/local/mysql/include #这里换成机器中mysql路径下的include
make
make install
```

- 4.测试是否安装成功

```
sysbench --version
```

关于测试应用参考书上P55

# 服务器性能剖析

通过性能剖析可以找到开销最大的任务，从而针对性的进行优化

将性能定义为完成某件任务所需要的时间度量，即`响应时间`，性能的优化就是在一定的负载下尽可能地降低响应时间

## MySQL剖析

对MySQL进行性能剖析很有用的工具是`慢查询日志`

### 剖析单条查询

- 1.使用SHOW PROFILE

首先启用PROFILE

```sql
SET profiling = 1;
```

执行任意查询语句后，使用

```sql
SHOW PROFILES;
```

它会为查询语句编号，并给出执行时间

也可以使用

```sql
SHOW PROFILE FOR QUERY 1;
```

它会给出执行该条查询语句时，执行的每一个步骤及其所需的时间

其中编号1是SHOW PROFILES时给出的Query_ID

- 2.使用SHOW STATUS

`SHOW (GLOBAL) STATUS`命令可以给出数据库的统计信息（通过计数器实现），比如客户端连接数，读写频率等

- 3.使用慢查询日志

通常慢查询是默认关闭的，可以使用

```sql
SHOW VARIABLES LIKE "%slow_query_log%";
```

来查看

然后使用

```sql
SET GLOBAL slow_query_log=1;
SET GLOBAL slow_query_log_file="your/own/path";
```

来分别设置开启慢查询日志和日志文件存放位置（CentOS系统日志默认存放位置是`/var/lib/mysql/hostname-slow.log`）

同时还需要设置慢查询时间`long_query_time`（默认是10s）

```sql
SET GLOBAL long_query_time=1;
```

注意这种方式只是临时设置，重启MySQL之后会丢失，想要永久设置需要编辑my.cnf文件，添加下面的内容后重启MySQL

```
[mysqld]
slow_query_log='ON'
low_query_log_file="your/own/path"
long_query_time=1
```

执行一个延时语句来测试（只要超过设置的long_query_time就会被记录）

```sql
SELECT SLEEP(3);
```

然后就可以查看日志文件中记录的内容

# Schema与数据类型优化

## MySQL中的数据类型

### 整数类型

MySQL有两种类型的数字：`整数`和`实数`

整数有以下几种类型：TINYINT(8位), SMALLINT(16位), MEDIUMINT(24位), INT(32位), BIGINT(64位)

也可以使用`UNSIGNED`指定为无符号整数，表示不允许负值

为整数类型指定宽度，如INT(11)，只是规定了`显式`字符的个数，在内部的存储和计算来说没有意义，INT(1)和INT(20)时相同的

### 实数类型

实数是带有小数部分的数字

其中FLOAT(4字节)和DOUBLE(8字节)支持用标准定浮点运算进行`近似计算`，DECIMAL类型用于存储`精确`的小数

由于CPU不支持DECIMAL的直接计算，MySQL服务器`自身实现`了DECIMAL的高精度计算，所以CPU自身支持的原生浮点计算会更快

MySQL将数字打包保存到一个`二进制字符串`中，每4个字节存9个数字，如DECIMAL(18, 9)将小数点两边的9个数字各使用4字节存储，小数点本身用一个字节存储，一共9个字节

DECIMAL类型最多存储65个数字，而且DECIMAL只是一种`存储格式`，计算式会转换为`DOUBLE类型`

### 字符串类型

字符串类型主要有VARCHAR和CHAR两种

- VARCHAR

VARCHAR是变长字符串，使用1或2个额外字节记录`字符串的长度`，它比定长类型更节省空间

- CHAR

CHAR是定长字符串，MySQL会根据定义的字符串长度分配存储空间，并`删除末尾空格`

### BLOB和TEXT类型

BLOB和TEXT分别是为存储二进制和字符`大数据`而设计的`字符串数据类型`

分别包括：TINYTEXT(BLOB), SMALLTEXT(BLOB), TEXT(BLOB), MEDIUMTEXT(BLOB), LONGTEXT(BLOB)

MySQL将BLOB和TEXT当作独立的对象处理，并且当BLOB和TEXT值太大时，InnoDB使用专门的`外部存储区域`来存储

### 枚举ENUM类型

可以使用枚举列把常用的不重复字符串存储成一个预定义的`集合`

如

```sql
CREATE TABLE enum_test(e ENUM('fish', 'apple', 'dog') NOT NULL);
```

创建了一个包含枚举列e的表enum_test，枚举列中`只能`插入定义的集合中的元素，否则会报错

并且e这一列中存储的是表示元素位置的整数，而在表的.frm文件中保存`数字-字符串`的映射关系

执行下面的语句：

```sql
INSERT INTO enum_test(e) VALUES('dog');
SELECT e FROM enum_test;
SELECT e+0 FROM enum_test;
```

第一条查询语句得到的结果是'dog'，而第二条语句得到的结果是3

### 时间类型

MySQL支持的最小时间粒度为`秒`，MariaDB支持微秒级别的时间类型

MySQL提供两种相似的日期类型：`DATETIME`和`TIMESTAMP`

- DATETIME

DATETIME格式将时间封装到格式为`YYYYMMDDHHMMSS`的整数中，与时区无关

- TIMESTAMP

使用`4字节`表示UNIX时间戳，只能表示1970年到2038年，它显示的值依赖于时区

### 位数据类型

- BIT

BIT类型在一列中存储一个或多个true/false值，`BIT(n)`指定包含n个位

MySQL将BIT当作`字符串类型`，但在数字上下文中检索时，得到的结果却是位字符串转换成的`数字`

比如一个值为b'00111001'，直接检索它得到的是`字符码为57的字符串'9'`，而在数字上下文中得到的就是数字57

- SET

SET是一系列打包的`位的集合`

## 范式与反范式

使用范式可以更好的减少重复数据，而且更新更快，但缺点是通常需要大量的`关联`

在实际应用中，通常需要结合范式与反范式，最常见的反范式化是`复制或缓存`，在不同的表中存储相同的特定列

只需要在缓存表中复制有用的列，这样就不会使得缓存表太大，而在进行查询操作时可以直接通过缓存表中的数据进行排序等复杂的操作，省去了关联表的开销

### 缓存表，汇总表和计数器表

在其他的表中保存衍生的冗余数据可以提高查询性能，常用的方法有三种：

- 缓存表

存储那些可以比较简单地从schema其他表获取数据的表

- 汇总表

保存使用GROUP BY语句聚合数据的表

- 计数器表

为某些事件（比如用户点击次数）计数

如果想要提高并发性，可以在计数器表中增加一个slot字段，并将计数器保存在`多行`中，每次根据slot的值`随机增加一个计数器`，在需要统计的时候去查询所有计数器行的`和`
