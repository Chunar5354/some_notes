# MySQL架构

MySQL架构的设计将`查询处理`、`其他系统任务`以及`数据的存储/提取`相分离

## MySQL逻辑架构

MySQL的服务器端有`三层逻辑架构`，最上层处理与客户端的连接，第二层是MySQL的核心功能，包括查询解析、分析、优化、缓存以及所有的内置函数，第三层是存储引擎，负责数据的存储和提取

每个客户端连接都在服务器进程中拥有一个`线程`，在5.5版本之后支持`线程池`插件，用池中的少量线程来服务大量的连接


## 并发控制

MySQL有两个层面的并发控制：服务器层与存储引擎层

### 读写锁

`共享锁-读锁`，`排他锁-写锁`

### 锁粒度

因为加锁需要额外的开销，所以要执行`锁策略`，在开销和数据的安全性之间做权衡

两种最重要的锁策略是`表锁`和`行级锁`

- 表锁

表锁是开销最小的策略，它会锁定`整张表`，而且写锁比读锁有更高的优先级

- 行级锁

行级锁能够最大程度地支持并发处理，但同时开销也最大

行级锁只在`存储引擎层`实现

## 事务

事务是`一组原子性的SQL查询`，只有能够成功执行全部的一组查询语句，这一组语句才会执行，只要有任何一条语句不能执行，那么所有的语句都不会执行

### ACID

`ACID`：原子性(automicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)

- 原子性

一个事务被视为不可分割的最小工作单元，整个事务中的所有操作要么全部成功提交(Commit)， 要么全部回滚(Rollback)

- 一致性

数据库总是从一个一致的状态转移到另一个一致的状态，因为如果事务没有提交，事务中所做的修改也不会保存到数据库中

- 隔离性

通常一个事务所做的修改在最终提交之前，对其他事务是不可见的

- 持久性

一旦事务提交，所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失

### 隔离级别

SQL标准定义了四个隔离级别，它们各自规定了一个事务中所做的修改，那些在事务内和事务间是可见的，哪些是不可见的

较低级别的隔离通常可以执行`更高的并发`，系统的开销也更低

- READ UNCOMMITTED 未提交读

READ UNCOMMITTED中，事务中的修改，即使没有提交，对其他事务也都是`可见的`，事务读取未提交的数据称为`脏读`

- READ COMMITTED 提交读

在READ COMMITTED级别，事务从开始到提交之前，所做的任何修改对其他事务是`不可见的`

READ COMMITTED级别也成为`不可重复读`，因为执行两次同样的查询，可能得到不一样的结果

大多数数据库默认的隔离级别都是READ COMMITTED（但MySQL不是）

- REPEATABLE READ 可重复读

REPEATABLE READ解决了脏读的问题，它保证在同一个事务中多次读取同一个记录的结果是`一致的`

但REPEATABLE READ无法解决`幻读`的问题，幻读指的是某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当第一个事务再次读取的时候，就会产生`幻行`（幻读可以通过MVCC的办法解决）

MySQL的`默认隔离级别`是REPAETABLE READ

- SERIALIZABLE 可串行化

SERIALIZABLE是最高的隔离级别，它强制事务`串行`执行（读取时加锁）

### 死锁

死锁指的是两个或多个事务在`同一资源`上互相占用，并请求锁定`对方占用的资源`，从而导致恶性循环

数据库会设置死锁检测和超时机制来解决死锁问题，InnoDB目前的方法是：`将持有最少行级排他锁的事务回滚`

死锁的产生可能有两种原因：真正的数据冲突或存储引擎的实现方式不当

发生死锁时，只有完全或部分回滚其中一个事务，才能打破死锁

### 事务日志

使用事务日志，存储引擎在修改数据是只需要修改其`内存拷贝`，再将`修改行为记录`保存到硬盘上的事务日志中，而不需要每次将修改的数据本身保存到硬盘

当事务日志被保存之后，内存中被修改的数据可以在`后台`慢慢刷回到磁盘

### MySQL中的事务

MySQL有两种事务型引擎：InnoDB和NDB Cluster

MySQL默认采用`自动提交(AUTOCOMMIT)`模式，如果不显式地开始一个事务，每个操作都会被当成一个事务来执行提交操作

MySQL中可以通过:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

来设置隔离级别，新的设置将在下一个事务开始生效

InnoDB采用两阶段锁定协议，事务过程中随时可以执行锁定，锁只有在执行`COMMIT`或`ROLLBACK`的时候才会释放，并且所有的锁在`同一时刻释放`

## 多版本并发控制 MVCC

可以认为MVCC是行级锁的变种，但它能在很多时候避免加锁操作，因此开销更低

MVCC是通过保存数据在某个时间点的`快照`来实现的，所以每个事务看到的数据取决于`事务开始的时间`，不同开始时间的事务在同一时刻可能看到的数据是不一样的

典型的MCVV有`乐观`并发控制和`悲观`并发控制

InnoDB的并发控制是通过在每行记录后面保存`两个隐藏的列`来实现的，两个列一个保存行的`创建时间`，一个保存`过期时间`，而且存储的不是实际的时间值，而是`系统版本号`

没开始一个新事务，系统版本号会`自动递增`，事务`开始时刻`的系统版本号作为`事务的版本号`

SELECT操作只会查找版本`早于当前事务版本`的数据行，此时改行的删除版本（过期时间）要么未定义，要么大于当前事务版本，这样使得大多数的读操作`不需要加锁`

MVCC只在`REPAEATABLE READ`和`READ COMMITTED`两个隔离级别下工作，另两个级别和MVCC不兼容

## MySQL的存储引擎

MySQL将每个数据库（schema）保存为文件系统中数据目录下的一个字目录（CentOS系统中存储在`/var/lib/mysql`）

每当创建一个表，将在数据库子目录中创建一个同名的`.frm`文件，用来储存`表的定义`，表中的数据存储在一个同名的`.ibd`文件中

### InnoDB

InnoDB是5.1版本之后的`默认存储引擎`，它被设计来处理`大量的短期事务`，它们大部分是正常提交的，很少会被回滚

InnoDB的数据存储在`表空间`中，它是一个由一系列数据文件组成的黑盒子

InnoDB采用MVCC来支持高并发，默认隔离级别是REPEATABLE READ，并且使用`间隙锁`(不只锁定查询涉及的行，还对索引中的间隙进行锁定，以防止幻行)

InnoDB表是基于`聚簇索引`建立的，它对于主键查询有很高的性能，但它的二级索引中必须`包含主键列`，所以主键的长度影响着所有索引的长度

InnoDB支持`热备份`，而其他存储引擎是不支持的

### MyISAM

MyISAM是5.1版本之前的默认存储引擎，它不支持`事务`和`行级锁`，但具有一些特性如全文索引、压缩和空间函数等

MyISAM对于较小的表、只读数据、能够忍受修复操作的场景应用较多，它的数据在崩溃后`无法安全恢复`

MyISAM将表存储在两个文件中：数据文件`.MYD`和索引文件`.MYI`

MyISAM对`整张表`进行加锁

# 基准测试

通过基准测试能够测试数据库或应用系统在给定应用场景下的实用性能，也可以找出系统存在的问题，是很有用的工具

主要介绍一种测试工具`sysbench`

## 安装sysbench

- 1.下载安装包并解压：

```
# wget https://github.com/akopytov/sysbench/archive/1.0.zip -O "sysbench-1.0.zip"
# unzip sysbench-1.0.zip
# cd sysbench-1.0
```

- 2.安装依赖

```
yum install automake libtool, kernel-headers –y
```

- 3.编译

```
./autogen.sh
./configure
export LD_LIBRARY_PATH=/usr/local/mysql/include #这里换成机器中mysql路径下的include
make
make install
```

- 4.测试是否安装成功

```
sysbench --version
```

关于测试应用参考书上P55

# 服务器性能剖析

通过性能剖析可以找到开销最大的任务，从而针对性的进行优化

将性能定义为完成某件任务所需要的时间度量，即`响应时间`，性能的优化就是在一定的负载下尽可能地降低响应时间

## MySQL剖析

对MySQL进行性能剖析很有用的工具是`慢查询日志`

### 剖析单条查询

- 1.使用SHOW PROFILE

首先启用PROFILE

```sql
SET profiling = 1;
```

执行任意查询语句后，使用

```sql
SHOW PROFILES;
```

它会为查询语句编号，并给出执行时间

也可以使用

```sql
SHOW PROFILE FOR QUERY 1;
```

它会给出执行该条查询语句时，执行的每一个步骤及其所需的时间

其中编号1是SHOW PROFILES时给出的Query_ID

- 2.使用SHOW STATUS

`SHOW (GLOBAL) STATUS`命令可以给出数据库的统计信息（通过计数器实现），比如客户端连接数，读写频率等

- 3.使用慢查询日志

通常慢查询是默认关闭的，可以使用

```sql
SHOW VARIABLES LIKE "%slow_query_log%";
```

来查看

然后使用

```sql
SET GLOBAL slow_query_log=1;
SET GLOBAL slow_query_log_file="your/own/path";
```

来分别设置开启慢查询日志和日志文件存放位置（CentOS系统日志默认存放位置是`/var/lib/mysql/hostname-slow.log`）

同时还需要设置慢查询时间`long_query_time`（默认是10s）

```sql
SET GLOBAL long_query_time=1;
```

注意这种方式只是临时设置，重启MySQL之后会丢失，想要永久设置需要编辑my.cnf文件，添加下面的内容后重启MySQL

```
[mysqld]
slow_query_log='ON'
low_query_log_file="your/own/path"
long_query_time=1
```

执行一个延时语句来测试（只要超过设置的long_query_time就会被记录）

```sql
SELECT SLEEP(3);
```

然后就可以查看日志文件中记录的内容

# Schema与数据类型优化

## MySQL中的数据类型

### 整数类型

MySQL有两种类型的数字：`整数`和`实数`

整数有以下几种类型：TINYINT(8位), SMALLINT(16位), MEDIUMINT(24位), INT(32位), BIGINT(64位)

也可以使用`UNSIGNED`指定为无符号整数，表示不允许负值

为整数类型指定宽度，如INT(11)，只是规定了`显式`字符的个数，在内部的存储和计算来说没有意义，INT(1)和INT(20)时相同的

### 实数类型

实数是带有小数部分的数字

其中FLOAT(4字节)和DOUBLE(8字节)支持用标准定浮点运算进行`近似计算`，DECIMAL类型用于存储`精确`的小数

由于CPU不支持DECIMAL的直接计算，MySQL服务器`自身实现`了DECIMAL的高精度计算，所以CPU自身支持的原生浮点计算会更快

MySQL将数字打包保存到一个`二进制字符串`中，每4个字节存9个数字，如DECIMAL(18, 9)将小数点两边的9个数字各使用4字节存储，小数点本身用一个字节存储，一共9个字节

DECIMAL类型最多存储65个数字，而且DECIMAL只是一种`存储格式`，计算式会转换为`DOUBLE类型`

### 字符串类型

字符串类型主要有VARCHAR和CHAR两种

- VARCHAR

VARCHAR是变长字符串，使用1或2个额外字节记录`字符串的长度`，它比定长类型更节省空间

- CHAR

CHAR是定长字符串，MySQL会根据定义的字符串长度分配存储空间，并`删除末尾空格`

### BLOB和TEXT类型

BLOB和TEXT分别是为存储二进制和字符`大数据`而设计的`字符串数据类型`

分别包括：TINYTEXT(BLOB), SMALLTEXT(BLOB), TEXT(BLOB), MEDIUMTEXT(BLOB), LONGTEXT(BLOB)

MySQL将BLOB和TEXT当作独立的对象处理，并且当BLOB和TEXT值太大时，InnoDB使用专门的`外部存储区域`来存储

### 枚举ENUM类型

可以使用枚举列把常用的不重复字符串存储成一个预定义的`集合`

如

```sql
CREATE TABLE enum_test(e ENUM('fish', 'apple', 'dog') NOT NULL);
```

创建了一个包含枚举列e的表enum_test，枚举列中`只能`插入定义的集合中的元素，否则会报错

并且e这一列中存储的是表示元素位置的整数，而在表的.frm文件中保存`数字-字符串`的映射关系

执行下面的语句：

```sql
INSERT INTO enum_test(e) VALUES('dog');
SELECT e FROM enum_test;
SELECT e+0 FROM enum_test;
```

第一条查询语句得到的结果是'dog'，而第二条语句得到的结果是3

### 时间类型

MySQL支持的最小时间粒度为`秒`，MariaDB支持微秒级别的时间类型

MySQL提供两种相似的日期类型：`DATETIME`和`TIMESTAMP`

- DATETIME

DATETIME格式将时间封装到格式为`YYYYMMDDHHMMSS`的整数中，与时区无关

- TIMESTAMP

使用`4字节`表示UNIX时间戳，只能表示1970年到2038年，它显示的值依赖于时区

### 位数据类型

- BIT

BIT类型在一列中存储一个或多个true/false值，`BIT(n)`指定包含n个位

MySQL将BIT当作`字符串类型`，但在数字上下文中检索时，得到的结果却是位字符串转换成的`数字`

比如一个值为b'00111001'，直接检索它得到的是`字符码为57的字符串'9'`，而在数字上下文中得到的就是数字57

- SET

SET是一系列打包的`位的集合`

## 范式与反范式

使用范式可以更好的减少重复数据，而且更新更快，但缺点是通常需要大量的`关联`

在实际应用中，通常需要结合范式与反范式，最常见的反范式化是`复制或缓存`，在不同的表中存储相同的特定列

只需要在缓存表中复制有用的列，这样就不会使得缓存表太大，而在进行查询操作时可以直接通过缓存表中的数据进行排序等复杂的操作，省去了关联表的开销

### 缓存表，汇总表和计数器表

在其他的表中保存衍生的冗余数据可以提高查询性能，常用的方法有三种：

- 缓存表

存储那些可以比较简单地从schema其他表获取数据的表

- 汇总表

保存使用GROUP BY语句聚合数据的表

- 计数器表

为某些事件（比如用户点击次数）计数

如果想要提高并发性，可以在计数器表中增加一个slot字段，并将计数器保存在`多行`中，每次根据slot的值`随机增加一个计数器`，在需要统计的时候去查询所有计数器行的`和`

## ALTER TABLE的优化

通常MySQL执行ALTER TABLE操作都方法是用新的结构创建一个空表，将旧表的数据插入信标，再删除旧表，但这样对空间和时间的消耗都比较大

通常ALTER TABLE会导致MySQL中断，可以使用`影子拷贝`技巧：先创建一个和源表五滚动信标，再通过`重命名`的方法交换两张表，这样就不会导致中断

或者可以只修改描述表结构的`.frm`文件，因为不涉及表数据，所以这种操作也比较快

# 创建高性能的索引

索引（key，键）是`存储引擎`用于快速找到记录的一种`数据结构`

## 索引类型

### B-Tree索引

大多数MySQL引擎都支持B-Tree索引（InnoDB使用的是B+Tree）

在B-Tree中，所有的值都是按`顺序`存储的，每一个节点表示`页`，每一个叶子页到根的距离都`相同`

使用B-Tree，存储引擎只需要从索引的根节点出发，根据节点槽中指向子节点的`指针`进行搜索，通过比较节点页的值和目标值可以找到合适的指针进入下一层，这些指针实际上定义了子节点页中值的`上界和下界`，最终要么找到目标值，要么目标值不存在

与其他节点不同，叶子节点指向的是`被索引的数据`，而不是其它节点页

因为B-Tree是按顺序组织的，所以很适合查找`范围数据`

B-Tree适用于`全键值`、`键值范围`或`键前缀`查找，具体包括以下几种：

- 全值匹配：匹配索引中的所有列

- 匹配最左前缀：只匹配索引的第一列

- 匹配列前缀：只匹配某一列的开头部分

- 匹配范围值：匹配某一列中在某个范围内的值

- 精确匹配某一列并范围匹配另一列

- 只查询索引列

### 哈希索引

对于每一行数据，存储引擎都会对`所有的索引列`计算一个哈希码，然后将所有的哈希码存储在索引中，同时在`哈希表`中保存指向每个数据行的指针

MySQL中只有Memory引擎支持哈希索引

InnoDB会为使用频率较高的索引值自动建立哈希索引，称为`自适应哈希索引`

### 空间数据索引 R-Tree

利用所有维度来组合查询

## 索引的优点

- 1.大大减少服务器需要扫描的数据量

- 2.帮助服务器避免排序和临时表

- 3.可以将随机I/O变为顺序I/O

## 高性能索引

### 1.独立的列

索引列不能包含在表达式中

### 2.前缀索引

有时索引列是很长的字符串，这时可以索引`开始的部分字符`，这样能够大大节约索引空间

不过这样会降低索引的`选择性`（不重复的索引值和数据表记录总数的比值），所以要在前缀长度和选择性之间做好平衡

创建前缀索引：

```sql
ALTER TABLE pre_test ADD KEY index(5);
```

上面的语句指定index列的前5个字符作为索引

MySQL在使用前缀索引时，无法ORDER BY和GROUP BY

### 3.多列索引

当需要多个列的数据共同进行索引的时候，最好将几个列共同定义为索引，如`KEY(c1, c2, c3)`，而不要分别定义索引再使用AND或OR操作符来联结

多列索引中如果有某一个索引列应用了`范围查询`，那么索引将到这一列为止，后面的列都不能使用索引了

### 4.合适的索引列顺序

再B-Tree中，如果是多列索引的话，索引首先按照`最左列`进行排序，然后依次向右，所以合理的安排索引列顺序能够加快ORDER BY等子句的性能

通常可以将`选择性最高`的列放在索引最前列

### 5.聚簇索引

聚簇索引指的是一种`数据存储方式`

在聚簇索引中，数据行存放在索引的`叶子页`中，一个表`只能有一个`聚簇索引

在InnoDB的聚簇索引中，叶子页包含了全部数据，节点页只包含`索引列`

MySQL中的引擎`不支持主动选择`哪个索引作为聚簇索引，InnoDB会将`主键列`作为聚簇索引，如果没有主键列，则会选一个`唯一的非空索`引代替，如果也没有这样的索引，InnoDB就会隐式地定义一个主键来作为聚簇索引

聚簇索引的优点：

- 1.将相关数据保存在一起，从磁盘读取少量的数据页就能获得全部信息

- 2.索引和数据行保存在同一个B-Tree中，所以速度更快

- 3.可以直接使用页节点中的主键值来进行`覆盖索引扫描`的查询

聚簇索引的缺点：

- 1.聚簇索引提高到是`I/O密集型应用`的性能，如果数据本身就存放在内存中，访问的顺序就不重要了

- 2.数据插入速度非常依赖插入顺序

- 3.因为每次都要要排序，所以更新聚簇索引列的代价很高

- 4.插入新行时可能导致`页分裂`问题

- 5.可能导致全表扫描变慢

- 6.因为二级索引（非主键，二级索引的叶子节点中存储的是`主键值`）会包含主键值，所以聚簇索引可能会导致二级索引变得很大


在MyISAM中，主键索引和其它索引没有区别，只是名为PRIMARY

但在InnoDB中，由于主键索引就是聚簇索引，每一个叶子页中会包含对应行的`全部数据`

尽量使用有顺序的`主键列`，这样插入时会简单地将新行插入到索引的最后，可以避免页分裂

### 6.覆盖索引

如果索引`包含`有所需要查询的字段的值，就称之为覆盖索引，这样在查询时就只需要扫描索引而不用访问源表

覆盖索引必须存储索引列的值，而哈希索引、空间索引与全文索引都不存储索引列的值，所以MySQL中只有B-Tree可以做覆盖索引

### 7.使用索引扫描做排序

除了通过排序操作，MySQL也可以使用索引扫描进行排序，但这要求索引的`列顺序`和ORDER BY子句的顺序完全一致，并且所有列的`排序方式都一样`（全部升序或全部降序），而且需要满足`最左前缀`的要求，进行关联查询时，还要求ORDER BY子句引用的字段全为`第一个表`才可以

### 8.前缀压缩索引

`MyISAM`中可以使用前缀压缩的方式来减少索引的大小，默认是压缩`字符串`，也可以设置为压缩整数

具体方法是：完全保存索引块的第一个值，然后将后面的每一个值与第一个值进行比较，得到相同前缀的`字节数`以及`剩余部分`，比如第一个值是abcd，第二个值是abcdef，则第二个值保存为"4, ef"的形式

### 9.重复和冗余索引

重复索引指的是在相同的列上按照相同的顺序创建相同类型的索引，应该尽量避免

冗余索引：如果有一个(A, B)索引，再创建一个A索引，那A就是冗余索引，因为A是(A, B)的前缀索引，而单独创建B索引则不是冗余索引

冗余索引有时能够加快某些查询的性能，但会降低插入性能，也应该尽量避免

### 10.索引与锁

使用索引可以减少要查询的行，从而减少对行的锁定，能够提高并发性

索引要尽可能过滤掉无效的行，否则检索到数据并发送到`服务器层`之后，MySQL才能使用WHERE子句，这就无法避免锁定行了

InnoDB中，`二级索引`使用共享锁，`主键索引`使用排他锁

## 维护索引和表

维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息和减少碎片

### 找到并修复损坏的表

可以使用`CHECK TABLE`来检查表是否损坏，并使用`REPAIR TABLE`来修复损坏的表(MyISAM)，但有些存储引擎不支持这个名令，此时可以通过一个不做任何操作的ALTER来修复，如：

```sql
ALTER TABLE innodb_tbl ENGINE=INNODB;
```

### 更新索引统计信息

MySQL的查询优化器通过records_in_range()和info()两个API来获取索引统计信息，并可以根据索引统计信息来估算`扫描行数`

可以使用`ANALYZE TABLE`来重新生成统计信息

使用`SHOW INDEX FROM`来查看表中索引的`基数`(Cardinality，它表示存储引擎估算索引列有多少个不同的取值)

### 减少索引和数据的碎片

B-Tree索引可能会碎片化（因为要按顺序），有三种类型的碎片：

- 行碎片：数据行被存储在多个地方的多个碎片中

- 行间碎片：`逻辑上是顺序`的行或页在磁盘上不按顺序存储

- 剩余空间碎片：数据页中含有大量的空余空间，这会导致服务器读取大量不需要的数据

MyISAM表中三种碎片都有可能发生，而InnoDB表中不会发生小的行碎片

可以使用`OPTIMIZE TABLE`或导出再导入的方法来重新整理数据，再InnoDB中可以通过先删除、再重新创建索引的方法来`消除索引碎片化`

对于不支持POTIMIZE TABLE的存储引擎，也可以使用`ALTER TABLE`空操作来消除碎片

- 总结：要尽量`避免单行查询`、尽可能使用`数据原生顺序`而避免额外的排序、尽量使用`覆盖索引`

# 查询性能优化

将查询看作一个任务，它由一系列子任务组成，优化查询实际上就是优化子任务，要么`消除`一些子任务，要么`减少`子任务的执行次数

## 优化数据访问

大部分性能低下的查询都可以通过`减少访问的数据量`的方式来进行优化

MySQL会默认返回全部结果集到客户端，可以通过LIMIT关键字来减少数据行

衡量查询开销有三个指标：响应时间、扫描的行数和返回的行数，他们都可以在慢查询日志中找到

### 响应时间

响应时间是`服务时间`和`排队时间`之和，服务时间指的是数据库处理查询的真正时间，排队时间指的是服务器因为等待某些资源花掉的时间，如等待IO操作或等待行锁等

### 扫描行数和返回行数

扫描行数与返回行数的比例能表征查询的`效率`，理想情况下它们应该相等，但实际上一般在1:1到1:10之间

### 访问类型

可以通过`EXPLAIN`语句来查看查询语句的访问类型

MySQL能用以下3种方式应用WHERE子句，从好到坏依次为：

- 1.在`索引`中使用WHERE条件来过滤记录，这是在`存储引擎层`完成的

- 2.使用`索引扫描覆盖`（EXPLAIN的Extra中出现`Using index`）返回记录，在索引中过滤，这是在`服务器层`完成的，但`无需再回表`进行查询

- 3.从`数据表`中返回数据，然后再过滤不满足条件的记录（Extra中出现`Using where`），这在`服务器层`完成，并需要先从`数据表`中读取记录然后过滤

## 重构查询方式

通常将一个大查询切分成许多个小查询可以提高性能，因为大查询通常会一次性锁定很多数据，阻塞其它的查询，比如删除一百万行数据可以分成一百次删除一万行数据来执行

将许多个表的关联查询分解成多个对单独表的简单查询也能够提高性能，它有以下几方面的优势：

- 1.让缓存的效率更高，关联查询中如果某个表发生了变动，那么整个查询都不能使用缓存，但拆分之后未改动的表就仍然可以使用缓存

- 2.单个查询可以减少锁的竞争

- 3.将数据在应用层做关联可以提高扩展性


## 查询执行方式

MySQL执行一条查询需要经过以下步骤：

- 1.客户端发送一条查询给服务器

- 2.服务器先检查`查询缓存`，如果缓存命中，则直接返回

- 3.如果缓存不命中，服务器端需要进行`SQL解析`、`预处理`，再由`优化器`生成对应的执行计划

- 4.根据`执行计划`，调用`存储引擎的API`进行查询

- 5.查询结果返回给客户端

### MySQL服务器/客户端通信协议

MySQL的服务器-客户端通信协议是`半双工`的，同一时刻只能有一方发送数据，并且在服务器推送数据的时候，客户端`不能打断`

多数连接MySQL的应用程序库函数都默认`一次获取全部结果`并`缓存`到内存中，接下来应用程序获取数据都是从库函数的缓存中获取

### 查询状态

每个MySQL连接也是一个线程，所以相应的任何时刻都有一个`状态`，使用`SHOW FULL PROCESSLIST`命令可以查看状态（Command列）

- Sleep：等待客户端发送新的请求

- Query：正在执行查询或正在将结果发送客户端

- Locked：在MySQL服务器层，线程正在等待`表锁`（行锁不会体现在线程状态中）

- Analyzing and statistics：正在收集存储引擎的统计信息，并生成查询的`执行计划`

- Copying to tmp table (on disk)：线程正在执行查询，并将结果都复制到一个临时表中(GROUP BY，UNION操作)，如果后面又on disk标记，说明正在将内存临时表放到磁盘上

- Sorting result：正在对结果集进行排序

- Sending data：可能在多个`状态之间`传送数据，或生成结果集，或在向客户端返回数据

### 查询缓存

缓存查询是通过一个`大小写敏感的哈希查找`实现的

如果缓存命中，在返回查询结果之前还会先检查一次`用户权限`

### 查询优化处理

如果缓存不命中，下一步是将SQL语句转换成执行计划，这中间包括多个子阶段：解析SQL、预处理和优化SQL执行计划

- 语法解析器和预处理

MySQL通过`关键字`解析SQL语句，并生成一棵对应的`解析树`

预处理器则会验证`解析树是否合法`，如数据表或列是否存在，或者名字是否有歧义，然后预处理器还会`验证权限`

- 查询优化器

MySQL使用基于`成本`的优化器，可以通过查询当前会话的`last_query_cost`的值来得知MySQL`计算`出的当前查询成本（返回的单位是`数据页`）：

```sql
SHOW STATUS LIKE 'last_query_cost';
```

MySQL的查询优化器使用两种类型的优化策略：

`静态优化`指的是直接对解析树进行分析，并完成优化，它不依赖参数，第一次完成后旧一直有效，是`编译时优化`

`动态优化`与查询的上下文有关，在每次查询的时候都需要重新评估，时`运行时优化`

- 统计信息

MySQL中数据和索引的统计信息由`存储引擎`实现，所以查询优化器在生成执行计划时，需要向存储引擎获取统计信息（包括表或索引的页数，索引的基数、长度等等）

- MySQL执行关联查询

MySQL认为任何一次查询都是一个`关联（JOIN）`

MySQL关联执行的策略是`嵌套循环关联`：先在一个表中循环取出单条数据，再循环嵌套到下一个表中找到`匹配的行`，依次进行直到找到所有表中匹配的行，然后根据匹配的行返回查询需要的记录

- 执行计划

MySQL为查询生成一棵`指令树`，存储引擎执行完成指令树并返回结果

- 关联查询优化器

关联查询优化决定了多个表关联时的`查询顺序`，多个表关联时会有很多种查询顺序，关联优化器会评估不同顺序时的成本来选择一个代价最小的关联顺序

可以使用`STRAIGHT_JOIN`关键字规定MySQL按照自己给出的顺序进行关联

- 排序优化

在不能通过索引进行排序的时候，MySQL需要自己进行排序，数据量小的时候在内存中进行，数据量大的时候则使用磁盘，MySQL将这个过程统称为`文件排序`

如果排序的数据量小于排序缓冲区，MySQL使用内存进行`快速排序`，如果内存不够，则先将数据`分块`，对每个块独立使用快速排序，并将各个块的结果存放在`磁盘`上，然后将排好序的块进行`合并`

MySQL有两种排序算法：

**1.两次传输排序（旧版本）**

读取行指针和`需要排序的字段`，排序后再根据排序结果读取所需的数据行

这个操作需要读取`两次`数据，且第二次数据读取的是被排序后的结果，会产生大量随机IO

优点是排序时使用尽可能少的数据，能更好的利用内存排序

**2.单次传输排序（新版本）**

读取`查询所需的所有列`，排序后`直接返回结果`

相比于两次传输排序，它只需要读取一次表，但排序时会占用更多空间

MySQL在排序时需要为每个记录分配足够的`定长空间`来存放，且在关联查询时如果ORDER BY子句中的列不是来自于第一个表，MySQL会将关联的结果存放到`临时表`中，在所有的关联都结束之后才进行排序，所以需要很大的数据空间

### 查询执行引擎

MySQL中执行计划是一个`数据结构`，MySQL根据执行计划调用存储引擎提供的`接口`(handler API)来完成查询

### 返回结果到客户端

在这个阶段查询可以被缓存，则需要将结果`缓存`

MySQL返回结果是一个`增量、逐步返回`的过程，所以服务器端无需存储太多的结果

MySQL结果的返回是基于`TCP`协议传输的

## 查询优化器的提示

对于特定的数据，MySQL默认的执行计划可能不能得到最好的性能，这时可以使用优化器的`提示(hint)`来对执行计划做出改动

通过在SQL语句中加上相应的提示关键字来实现，具体的关键字请查看书P233

# MySQL高级特性

## 分区表

对用户来说，分区表是`一个独立的逻辑表`，但底层由`多个物理子表`组成

实现分区的代码就是一组底层表的`句柄对象`(Handler Object)的封装，在文件系统中，分区表都有一个使用`#`分隔命名的表文件

MySQL实现分区表的方式是`对底层表的封装`，创建表的时候使用`PARTITION BY`子句定义每个分区存放的数据，查询时优化器会自动`过滤`没有目标数据的分区

使用分区表可以将大表的数据进行拆分，只对其中一部分做修改，而且可以分布在不同的物理设备上

### 分区表的原理

从存储引擎的角度来看，底层表和普通表没有区别

在对分区表进行操作时，分区层会首先`打开并锁住`所有的底层表，然后选择合适的分区进行操作

### 分区表的类型

MySQL中最常用的分区类型是根据`范围`进行分区，如：

```sql
CREATE TABLE sales (
    order_date DATETIME NOT NULL,
    -- Other columns omitted
) ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date)) (
    PARTITION p_2010 VALUES LESS THAN (2010),
    PARTITION p_2011 VALUES LESS THAN (2011),
    PARTITION p_2012 VALUES LESS THAN (2012),
    PARTITION p_catchall VALUES LESS THAN MAXVALUE
);
```

其中PARTITION子句中表达式的返回值需要时一个`确定的整数`（如上面的YEAR()）

### 如何使用分区表

数据量巨大的时候，使用索引的代价非常高，而使用分区就可以将数据细化，从而在小的数据区间驱动更好的查询性能

保证大数据量的可扩展性一般由两个策略：

- 1.全量数据扫描，不要任何索引

用简单的分区存放表，不使用索引，根据分区的规则来`大致定位`需要的数据位置

但是应该将需要`扫描的分区个数`限制在一个小的数量

- 2.索引数据，并分离热点

将访问频率很高的热点数据单独放在一个分区中，这样能够高效的利用缓存

使用分区表时分区的列和索引列尽量要匹配

### 查询优化

在查询语句中的WHERE条件加入`分区列`，优化器就会自动对可能的分区进行过滤，如：

```sql
SELECT * FROM sales WHERE day > '2011-01-01';
```

就会自动过滤掉小于2011年的分区

不过要注意WHERE后的条件必须是使用`分区的列本身`，而不能根据表达式的值来过滤，像下面的语句是不能执行分区过滤的

```sql
SELECT * FROM sales WHERE YEARS(day) = 2010;
```

可以将它改成：

```sql
SELECT * FROM sales WHERE day BETWEEN '2011-01-01' AND '2011-12-31';
```


## 视图

视图本身是一个`虚拟表`，`不存放`任何数据，它返回的数据是MySQL从`其他表`中生成的

创建视图：

```sql
CREATE [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 
    VIEW view_name AS
    select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]
```

MySQL处理视图有两种方法：合并算法和临时表算法

- 合并算法：服务器将视图SQL和查询SQL进行合并后，用重写的SQL到底层表中进行查询

- 临时表算法：将查询SQL的结果存放到临时表种，访问视图的时候直接访问临时表

### 可更新视图

可更新视图指的是可以通过更新视图来`更新视图涉及的表`

需要注意，通过临时表算法实现的视图`无法被更新`

如果视图定义中包含了GROUP BY, UNION, 聚合函数，或更新的列是`定义列以外的列`时，不能被更新

## 外键

MySQL中只有InnoDB支持外键，它强制外键使用索引

多数时候使用外键的性能并不好，可以把需要做的关联放到应用程序中

## 在MySQL内部存储代码

MySQL允许通过`触发器`、`存储过程`、`函数`和`事件`的形式来存储代码

### 存储过程和函数

当查询很小的时候，相比于查询的成本，解析和网络开销就变得明显，这时使用存储过程的方法就能有效提高速度

### 触发器

触发器可以在执行`INSERT`、`UPDATE`或`DELETE`的时候执行一些特定的操作

触发器本身没有返回值，他们可以读取或改变触发SQL语句所`影响的数据`

在MySQL中，对于每一个表的每个事件，最多只能定义`一个触发器`，且MySQL只支持`基于行的触发`，触发器只能够针对一条记录

在InnoDB表中触发器是在同一个事务中完成的，所以是原子的，而在MyISAM中却不是

### 事件

事件类似于Linux的定时任务，可以指定MySQL在某个时候或每隔一个时间间隔执行一段SQL代码

## 绑定变量

是一种特殊的SQL语句，使用`?`标记接收参数的位置，如：

```sql
INSERT INTO tb1(col1, col2, col3) VALUES (?, ?, ?);
```

客户端向服务器发送这个SQL语句，服务器收到之后，解析并存储这个语句的`部分执行计划`，返回给客户端一个语句处理句柄，之后客户端使用`句柄`来执行这个查询

使用绑定变量，服务器只需要解析一次SQL语句，并且每次只需要将参数发送到服务器，能够节省网络开销

绑定变量可以有三种类型：

- 1.客户端模拟的绑定变量：客户端程序接收一个带参数的SQL，之后将值带入其中，最后将完整的SQL发送到服务器

- 2.服务器端的绑定变量：客户端使用二进制协议将带参数的字符串发送到服务器端，之后再用二进制协议将具体的参数值发送到服务器端并执行

- 3.SQL接口的绑定变量：客户端使用普通文本传输协议将一个带参数的字符串发送到服务器端，然后发送设置参数的SQL，再使用EXECUTE来执行SQL

## 字符集和校对

字符集指的是从二进制编码到某类字符符号的`映射`，校对是指一组用于某个字符集的`排序规则`

MySQL中字符集和校对总是共同出现的，所以统称为字符集

MySQL中对于字符集的设置可以分为两类：创建对象时的默认值、服务器和客户端通信时的设置

- 创建对象时的默认值

在创建数据库、创建表和创建列的之后都可以指定其字符集，当没有在列中指定字符集的时候，将使用表的默认设置，如果还没有则使用数据库的默认设置

- 通信时的设置接收客户端传输时，默认使用`character_set_client`中的设置，服务器接收到客户端的SQL语句时，将其转换成`character_set_connection`的设置，
服务器返回信息给客户端时，使用`character_set_result`中的设置

只有排序时指定的字符集与数据字符集相同的时候，才能使用`索引排序`

## 全文索引

使用全文索引时，MySQL会将需要索引的列全部拼接成`一个字符串`，然后进行索引

MySQL的全文索引是一类特殊的`B-Tree索引`，共有两层，第一层是所有`关键字`，然后每个关键字的第二层包含的是一组相关的`文档指针`

全文索引不会存储关键字匹配在哪一列

### 自然语言的全文索引

自然语言搜索引擎计算文档对象和查询的`相关度`，相关度基于匹配的关键词`个数`，以及关键词在文档中出现的`次数`

在`整个索引`中出现次数`越少`的词语，匹配时的相关度越高，如果某个词在超过50%的记录中都出现了，将不会被搜索

### 全文索引的限制

MySQL的全文索引只有全部在`内存`中的时候，性能才非常好

只要SQL语句出现了MATCH AGAINST子句，而对应列上又有全文索引，MySQL就一定会执行全文索引，而不管其他的索引

全文索引不存储列的实际值，不能用作`索引覆盖扫描`

全文索引只有在相关性排序时可以用索引排序，其它都是`文件排序`

## 分布式（XA）事务

分布式事务使得存储引擎级别的ACID可以扩展到`数据库层面`，乃至多个数据库之间

XA事务中有一个`事务协调器`来确保所有的事务参与者都完成了准备工作（第一阶段），如果所有参与者都准备好，就告诉所有的事务可以提交了（第二阶段）

MySQL中的XA事务分为内部和外部两种

### 内部XA事务

内部事务可以协调多个存储引擎和二进制日志

### 外部XA事务

MySQL作为参与者完成外部的分布式事务

## 查询缓存

MySQL除了能够缓存查询的执行计划，也能够缓存完整的`SELECT查询结果`，称为查询缓存

查询缓存系统会跟踪涉及的每个表，如果有表发生变化，那这个表相关的所有缓存数据都将`失效`

### 缓存命中的判断

MySQL的缓存存放在一个引用表中，通过`哈希值`引用，哈希值是由查询本身、要查询的数据库以及客户端协议版本等因素共同计算得到的

MySQL不会使用解析后的SQL语句来进行缓存判断，而是直接使用客户端发送的`原始SQL语句`，所以任何`字符上的不同`（空格，注释等）都会导致缓存不命中

查询语句中有一些`不确定`的数据时（如NOW()函数等），则不会被缓存

打开查询缓存对读和写操作都会带来额外消耗，且查询缓存操作是一个`加锁排他操作`

### 查询缓存与内存

查询缓存是完全存储在`内存`中的，同时需要一部分空间来存储管理维护数据结构

当有查询结果需要缓存的时候，MySQL先从整个空间申请一个数据块用于存储结果，无论查询结果多大，都需要根据`query_cache_min_res_unit`的配置来申请数据块大小，申请时需要`锁`住整个空间块

# 优化服务器设置

## MySQL配置原理

配置内容一般要写在`/etc/my.cnf`里面的`[mysqld]`字段下，这样才能永久的更改配置

如果在运行时动态地修改了全局变量，那么这个修改只会在当前会话之后的会话其效果，可以通过`SHOW GLOBAL VARIABLES`来查看变量的配置情况

## MySQL最小配置文件

尽量不要为MySQL设置太多的配置项以避免陷阱，下面是一个合适的示例配置文件

```
# /etc/my.cnf
[mysqld]
# GENERAL
datadir                         = /var/lib/mysql   # 数据存储路径
socket                          = /var/lib/mysql/mysql.sock
pid_file                        = /var/lib/mysql/mysql.pid
user                            = mysql
port                            = 3306
default_storage_engine          = InnoDB  # 默认存储引擎
# INNODB
innodb_buffer_pool_size         = <value>  # 缓冲池，根据情况设置成合适的大小
innodb_log_file_size            = <value>  # 日志文件大小
innodb_file_per_table           = 1
innodb_flush_method             = 0_DIRECT
# MyISAM
key_buffer_size                 = <value>
# LOGGING
log_error                       = /var/lib/mysql/mysql-error.log
slow_query_log                  = /var/lib/mysql/mysql-slow.log
# OTHER
tmp_table_size                  = 32M
max_heap_table_size             = 32M
query_cache_type                = 0
query_cache_size                = 0
max_connections                 = <value>
thread_cache                    = <value>
table_cache                     = <value>
open_files_limit                = 65535
[client]
socket                          = /var/lib/mysql/mysql.sock
port                            = 3306
```

## 配置内存使用

MySQL的内存消耗可以分为可控制内存和不可控制内存

不可控制内存包括MySQL服务器运行、解析查询以及内部管理所消耗的内存

内存配置的步骤：

- 1.确定可以使用的内存上限

- 2.确定每个MySQL连接需要使用多少内存，如排序缓冲和临时表

- 3.确定操作系统及其它程序需要多少内存

- 4.剩余的内存`全部给MySQL的缓存`

MySQL比较重要的缓存包括：

- InnoDB缓冲池

- InnoDB日志文件和MyISAM数据的操作系统缓存

- MyISAM键缓存

- 查询缓存

- 二进制日志和表定义文件的操作系统缓存等无法手动配置的缓存

### InnoDB缓冲池

InnoDB缓冲池会缓存`索引`、`行的数据`、`自适应哈希索引`、`插入缓冲`、`锁`、以及其他`内部数据结构`

InnoDB还使用缓冲池来帮助`延迟写入`，以合并多个写入操作，一起顺序写回

### MyISAM键缓存

MyISAM自身`只缓存索引`，不缓存数据（数据依赖操作系统缓存）

MyISAM默认只有一个键缓存，可以手动创建，在配置文件里添加：

```
key_buffer_1.key_buffer_size = 1G
key_buffer_2.key_buffer_size = 1G
```

就新建了两个名为key_buffer_1和key_buffer_2的键缓存，通过下面的语句来指定使用键缓存：

```sql
CACHE INDEX t1, t2 IN key_buffer_1;
```

指定了t1和t2表中的索引使用key_buffer_1来进行缓存，MySQL在表中的索引`读取块时`，会在指定的缓存区内缓存这些快


MyISAM键缓存块不要太小，否则会出现`写时读取`的情况:

假设操作系统的页大小是4KB，索引块是1KB，则操作步骤为：

- 1.MyISAM请求从磁盘上读取1KB的块

- 2.操作系统读取4KB的数据并缓存，发送需要的1KB数据给MyISAM

- 3.操作系统丢弃缓存数据以腾出缓存空间

- 4.MyISAM修改1KB的数据块，请求操作系统将其写回磁盘

- 5.因为系统页的单位是4KB，所以操作系统需要先读出`原来的4KB数据`，写入操作系统缓存，再将`被MyISAM修改的1KB数据`修改，然后将整个4KB数据写回磁盘

在第5步中，写回磁盘时发生了写时读取，如果索引块大于4KB则不会发生这种情况

### 线程缓存

线程缓存保存当前没有与连接关联但是准备为后面`新的连接`服务的线程

当新连接创建时，如果缓存中有线程存在，MySQL将从缓存中`删除一个线程`，并分配给新的连接

当连接关闭时，如果线程缓存有空间的话，MySQL会把线程`放进缓存`，否则销毁线程

### 表缓存

表缓存对于MyISAM表比较有用，MySQL会对表进行计数，当打开时计数器递增，关闭时递减，这样在打开一个表时，如果计数器不为0，说明表没有关闭完全，正在使用中，这样做的好处是不需要修改MyISAM的文件就能够加上`使用中标记`

### InnoDB数据字典

InnoDB有自己的表缓存，层为数据字典，每当InnoDB打开一个表，就增加一个对应的对象到数据字典，表关闭的时候也`不会`从数据字典中移除

## MySQL的I/O行为

### InnoDB的I/O配置

InnoDB可以配置很多文件和缓存，其中比较重要的有InnoDB`日志文件大小`、InnoDB`日志缓冲刷新方式`，以及InnoDB`怎样执行I/O`

- InnoDB事务日志

InnoDB中可以使用日志来减少提交事务时的开销，将事务保存在日志中，就无需在每个提交时将缓冲池的脏块刷新到磁盘中

事务修改的数据通常会映射到表空间的随机位置，通过日志可以将`随机I/O变成顺序I/O`，通过一个`后台线程`自动刷新到磁盘

InnoDB的日志是`环形方式写`的，如果日志写满，新的内容会覆盖开头的日志

每当InnoDB变更任何数据是，都会写一条记录到内存日志缓冲区，当`缓冲满的时候`、`事务提交的时候`或`每一秒钟`，InnoDB都会刷新缓冲区的内容到磁盘日志文件

注意日志缓冲写到日志文件和刷新到持久化存储是不一样的，写到日志文件知识把数据从InnoDB的内存缓冲转移到了操作系统的缓存，数据`仍然在内存里`，而刷新到持久化存储才是写到了磁盘上，这样断电也不会丢失数据

### InnoDB的表空间

InnoDB将数据保存在表空间内，本质上是一个由一个或多个磁盘文件组成的`虚拟文件系统`

表空间除了存储表和索引，还保存了回滚日志、插入缓冲、双写缓冲、以及其它内部数据结构

可以在`my.cnf`中定制表空间文件，如：

```
innodb_data_home_dir    = /var/lib/mysql
innodb_data_file_path   = ibdata1:1G;ibdata2:2G
```

创建了两个表空间，以及它们的存放位置

回收表空间的`唯一方式`是导出数据，关闭MySQL，删除文件，修改配置，重启

如果简单的删除文件或改变大小可能导致`表空间损坏`，此时InnoDB会拒绝启动

- 双写缓冲

InnoDB用双写缓冲来避免`页没写完整`导致的数据损坏

双写缓冲是表空间的一个特殊的保留区域，本质上是一个`最近写回的页面`的`备份拷贝`

InnoDB从缓冲池刷新页面到磁盘时，首先写到双写缓冲，然后再写到所属的数据区域中，意味着要写`两次`，但是是在同一次`fsync()`调用中完成的，所以对性能几乎没有影响

### MyISAM的I/O配置

MyISAM通常`每次写操作之后`就把索引变更刷新到磁盘

可以通过`delay_key_write`变量来设置键缓存，以及`myisam_recover_options`来设置表的检查与修复

## MySQL并发配置

### InnoDB并发配置

如果在高并发场景下InnoDB的性能很低，就需要限制并发

可以通过`innodb_thread_concurrency`变量来设置一次性能够有多少个线程进入内核

或使用线程池（MariaDB）

### MyISAM并发配置

对于MyISAM来说，删除操作不会重新整理整个表，而只是将行标记为删除，在表中留下`空洞`，并在后面的插入时填满这些空洞

MyISAM不支持MVCC，需要配置`concurrent_insert`来配置并发插入

# 操作系统和硬件优化

对于MySQL服务器硬件来说，最常见的性能瓶颈往往出现在CPU或I/O

## 如何选择CPU

调优服务器大多有以下两个目标：

- 低延时：需要高速CPU，因为每个查询只能使用一个CPU

- 高吞吐：有多个CPU就可以同时运行很多查询

数据库并发问题有两种;

- 逻辑并发问题：可以以通过更好的策略来解决，如修改应用程序，优化服务器配置

- 内部并发问题：如信号量，InnoDB缓冲池资源争用等问题，可以通过改变服务器操作系统，改变硬件的方法来缓解，通常不能彻底解决

## 平衡内存和磁盘

配置大内存的最终目的是`避免磁盘I/O`，因为磁盘I/O很慢

### 随机I/O和顺序I/O

顺序读取一般`只扫描一次数据`，所以缓存对它提升不大，另外一个原因是顺序读取`比随机读取快`，有两个方面：

- 顺序I/O比随机I/O快

- 存储引擎执行顺序读比随机读快，通常随机读意味着存储引擎需要使用`索引`，需要使用B数结构，而顺序读只需要读取链表

### 缓存与写操作

写操作可以在内存中完成，但最终一定要在磁盘上持久化，缓存只能够`延缓写入`，但不能消除写入

缓存除了可以延缓写入，还可以把多个写入`集中操作`，有两个途径：

- 多次写入，一次刷新：数据可以在内存中改变多次，而只把最后一次改变刷新到磁盘

- I/O合并：许多不同部分的数据可以在内存中修改，最终合并在一起通过一次磁盘操作刷新到磁盘

### 工作集

工作集指的是执行一个操作`确实需要的数据`

应该依据最常用的页面集来考虑工作集，尽量将工作集全部放在内存中

## 固态存储

固态存储设备使用`非易失性闪存芯片`而不是磁性盘片组成

相比于磁盘，固态存储能够提高随机I/O和并发性能

### 闪存概述

闪存的主题要特征是可以迅速完成`多次小单位读取`，写入操作比较复杂：改写一个单元之前首先要进行`擦除`，且一次必须擦除一个`大块`，擦除操作较慢并会`磨损`整个块

为了保持一些块是干净的并可以被写入，闪存通过垃圾收集来回收脏块，所以设备在被填满后会开始变慢

闪存设备主要有两种类型：`单层单元`（SLC）和`多层单元`（MLC）

- SLC每个单元存储`一个比特`，它速度快，擦写周期长，但存储密度（容量）较低，且比较昂贵

- MLC每个单元存储2个比特，相比于SLC，他速度较慢且擦写周期断，但容量更大，成本更低

### Flashcache

Flashcache是磁盘和内存技术的结合，它创建一个块设备，并且可以被分区也可以创建文件系统，而这个块设备是由闪存和磁盘共同支撑的，`闪存设备`作为磁盘的高速缓存

所以在数据库下层至少有三层缓存：

- 1.InnoDB缓冲池，它的缓存命中很快，响应时间均匀

- 2.如果缓冲池没有命中，就到`Flashcache设备`上去取

- 3.入宫Flashcache也没有命中，就到磁盘上去取，它的响应时间分布均匀，但比较慢
