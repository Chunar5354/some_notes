# 存储器层次结构

存储器系统是一个层次的结构，包括：

- 1.CUP寄存器
- 2.靠近CUP的高速缓存存储器
- 3.主存储器
- 4.磁盘
- 5.通过网络连接的其他设备

每一层都作为下一层的`缓存`区域

## 存储技术

### 随机访问存储器

随机访问存储器（Random-Access Memory RAM）分成两类：静态（SRAM）和动态（DRAM）

- 1.SRAM

SRAM用作`高速缓存存储器`，可以在CPU上也可以在片下，它将每个位存储在一个`双稳态`的存储器单元里，每个单元由`6个晶体管`构成

由于双稳态的特性，只要有电，SRAM就会`永远`保持它的值

通常SRAM不会超过`几兆`字节

- 2.DRAM

DRAM用作`主存`（内存）以及图形系统的帧缓冲区，每个位由`一个晶体管`和`一个电容`构成

DRAM是`不稳定`的，当电容电压被扰乱之后，就不能恢复了

DRAM芯片封装在`内存模块`中，插到主板的扩展槽上，现代内存模块（以Core i7为例）使用240个引脚的`双列直插内存模块`，以64位为块与`内存控制器`互相传输数据

### 非易失性存储器

SRAM和DRAM在断电时会失去信息，他们是易失的

`只读存储器（Read-Only Memory）`是非易失的

根据能够被重编程的次数和重编程的机制将ROM分类：

PROM只能被编程`一次`，可擦写可编程EPROM通过紫外线照射窗口擦除，重编程次数可达1000次，电子可擦除EEORPM能够达到100000次

`闪存`是基于EEPROM的，固态硬盘是基于闪存的


### 磁盘

磁盘由`盘片`构成，每个盘片有两个`表面`，每个表面有一组被称为`磁道`的同心圆组成，每个磁道被划分为一组`扇区`

通常用`柱面`来描述多个盘片驱动器的构造

磁盘用`读/写头`来读写表面上的位，其访问时间主要分为：`寻道时间`、`旋转时间`和`传送时间`，延时主要发生在寻道和旋转延时

磁盘格式化时，会预留一些`备用`的柱面，所以实际的容量会比标称的容量小

- 通用串行总线（Universal Serial Bus USB）

- 内存映射I/O：地址空间中有一块地址是为与I/O设备通信保留的，每个地址称为一个`I/O端口`

- 访问磁盘

    - 1.CPU发起一个磁盘读
    - 2.磁盘读取扇区，并执行向主存的DMA（Direct Memory Access）传送
    - 3.磁盘控制器向CPU发送中断信号来通知CPU传输完成

### 固态硬盘

固态硬盘（Solid State Disk）是基于闪存的存储技术

一个SSD封装由一个或多个`闪存芯片`和`闪存翻译层`组成

一个闪存由多个`块`组成，一个块由多个`页`组成

### 存储器层次结构

上一层是下一层的缓存

每一层的数据被划分成连续的数据对象`块`

第k层的存储器被划分为比k+1层更少的块的集合

当程序需要k+1层的某个对象d时，如果d刚好缓存在第k层中，称为`缓存命中`，否则第k层需要向第k+1层读取，称为`缓存不命中`

当第k层的缓存满时，就需要用k+1层的块`覆盖`现存的一个块，需要由`替换策略`来决定替换哪一个块

### 高速缓存

可以依次划分为`组`、`行`、`块`

尽量使不同元素的地址映射到不同的组中，来避免冲突

替换策略：最不常使用 Least-Frequently Used `LFU`，最近最少使用 Least-Recently Used `LRU`

写缓存时，有两种方法：

- 1.直写，将已经缓存的字w`立即`写到下一层

- 2.写回，尽可能地推迟更新，直到替换算法将要`驱逐`这个块，它能显著地减少总线流量，但实现起来更复杂

#### 层次结构

以Core i7为例，CPU芯片有4个核，每个核有自己`私有的`L1 i-cache（指令缓存）和L2 d-cache（数据缓存）和L2统一高速缓存，所有的核`共享`L3统一的高速缓存

## 局部性

具有局部性的程序倾向于引用`临近于`其它`最近引用过`的数据项的数据项

- 时间局部性：被引用过一次的内存位置可能在不久的将来`再被多次引用`

- 空间局部性：如果一个内存位置被引用了一次，那么程序可能在不久的将来引用`它附近`的一个内存位置

## 链接

链接是将各种代码和数据片段收集并组合成为一个`单一文件`的过程

链接可以执行与`编译时`、`加载时`和`运行时`，通过`链接器`自动执行

c语言编译的过程：源程序`main.c`，ASCII码中间文件`main.i`，ASCII汇编语言文件`main.s`，可重定位目标文件`main.o`，可执行文件`prog`

### 静态链接

静态链接器以一组`可重定位目标文件`和`命令行参数`为输入，生成一个完全链接的、可以加载和运行的`可执行文件`为输出

输入的可重庆薇目标文件由各种不同的`代码`和`数据节`组成

链接器有两个最主要任务：

- 1.符号解析：目标文件中符号对应定义的变量，符号解析的目的是将符号`引用`和符号`定义`关联起来

- 2.重定位：将每个符号定义与一个`内存位置`关联起来

### 动态链接共享库

共享库是一个目标模块，在运行或加载时，可以加载到`任意的`内存地址（`位置无关代码`），并和一个在内存中的`程序链接起来`，这个过程称为`动态链接`

共享库在Linux中通常用.so后缀表示

对于一个给定的文件系统，每一个库`只有一个`.so文件，所有引用该库的可执行目标文件`共享`这个.so文件中的代码和数据，而不需像静态库那样将内容复制到可执行文件中，这样减少了内存开销

### 加载可执行目标文件

运行可执行文件时，通过某个驻留在存储器中称为`加载器`的操作系统代码来执行它

任何Linux程序都可以通过调用execve程序来调用加载器，将程序复制到`内存`并执行


# 异常控制流

## 异常

在处理器中，程序计数器有一个值的序列a1,a2...ak,ak+1，每个ak是相应的指令Ik的地址，从ak到ak+1的过渡称为`控制转移`，一个控制转移序列称为处理器的`控制流`

现代系统通过是控制流发生`突变`来响应事件，将这些突变称为`异常控制流（Exceptional Control Flow ECF）`

ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制，应用程序通过`陷阱`或者`系统调用`的ECF形式向操作系统请求服务

### 异常的处理

系统中为每一类型的异常都分配了唯一的`异常号`，并存放在一张称为`异常表`的跳转表中

程序运行时，当系统检测到一个事件，并确定其异常号k，将会执行`间接过程调用`，同过异常表的表目k，转到相应的处理程序

异常处理程序运行在`内核模式`下，它们对所有的系统资源都有`完全的访问权限`

### 异常的分类

异常可以分为4类：中断、陷阱、故障和终止

- 1.中断

中断是`异步`发生的，是来自处理器外部的`I/O设备的信号`的结果，处理结束返回时总是返回到`下一条指令`

除了中断以外的其他三种异常都是`同步`发生的，是执行`当前指令`的结果

- 2.陷阱和系统调用

陷阱是`有意`的异常，是执行一条指令的结果，它也返回到`下一条指令`

陷阱最重要的用途是提供一个像过程一样的接口，称为`系统调用`，用于用户程序对`内核服务`的访问

当用户想要请求内核服务n时，将执行`syscall n`指令，它会导致一个到异常处理程序的陷阱

- 3.故障

故障由`错误情况`引起，当故障发生时，处理器将控制转移给故障处理程序，如果它能`修正`这个故障，就将控制返回给引起故障的指令（原指令）并`重新执行`它，否则处理程序返回到内核中的`abort`例程，它将`终止`引起故障的应用程序

- 4.终止

终止是不可恢复的`致命错误`造成的结果，通常是硬件错误，终止处理程序直接将控制返回给abort例程，终止这个应用程序

## 进程

进程可以定义为一个`执行中程序的实例`，系统中的每个程序都运行在某个进程的`上下文`中，上下文是由`程序正确运行所需的状态`组成的

进程为应用程序气筒两个关键`抽象`：

- 1.一个独立的逻辑控制流，它提供一个假象，好象每个程序`独占处理器`

- 2.一个私有的地址空间，它提供一个假象，好象每个程序`独占内存系统`

### 逻辑控制流

进程是`轮流使用`处理器的，每个进程执行它的流的一部分，然后被`抢占`（暂时挂起），然后轮到其它进程

### 并发流

一个逻辑流的执行在`时间上`与另一个流重叠，称为`并发流`

多个流并发的执行的现相称为`并发`，一个进程和其它进程轮流运行的概念称为`多任务`，一个进程执行它的控制流的一部分的每一时间称为`时间片`，多任务也成为`时间分片`

如果两个流并发的运行在不同的处理器或计算机上，称它们为`并行流`

### 私有地址空间

一台n位的计算机上，地址空间是`2^n`个可能地址的集合，进程为每个应用程序提供它自己的`私有地址空间`，这个空间中某个地址相`关联的内存`是不能被其它进程读写的

### 用户模式与内核模式

处理器需要提供一种机制来限制一个应用可以执行的指令以及它可以访问到地址空间

通常是使用某个`控制寄存器`的一个`模式位`来实现的，设置了模式位时，进程运行在`内核模式`中，内核模式运行的进程可以访问任何地址空间，执行任何指令；

反之则运行在`用户模式`中，用户模式的程序不允许执行特权指令，也不允许直接引用内核区的代码和数据，用户程序必须通过`系统调用接口`间接的访问内核代码和数据

进程从用户模式切换到内核模式的唯一方法是通过诸如中断、故障或陷入系统调用这样的`异常`

### 上下文切换

内核为每个进程维持一个上下文，上下文是内核重新启动一个被抢占的进程所需的`状态`

内核可以决定是否抢占当前进程并恢复一个其它进程，这种策略称为`调度`，通过`调度器`完成

## 进程控制

每个进程都有唯一的正数进程ID（PID）

### 创建和终止进程

进程总是处于以下三种状态之一：

- 1.运行，运行中的进程要么在CPU上`执行`，要么在`等待被执行`且最终会被内核调度

- 2.停止，停止的进程被`挂起`，且不会被调度，直到收到一个SIGCONT信号，进程再次开始运行

- 3.终止，进程永远停止了，终止可能由三种原因引起：收到终止进程的`信号`、从`主程序返回`或调用`exit函数`

父进程通过调用`fork函数`创建一个新的运行的子进程

- 新创建的子进程几乎与父进程完全相同，它们最大的区别是具`有不同的PID`

- fork函数直被调用一次，却返回`两次`，一次是在调用父进程中，一次是在新创建的子进程中，在父进程中，fork返回`子进程的PID`，再子进程中fork返回`0`，这样就可以`区分`程序是在父进程还是在子进程中执行

- 父进程与子进程是`并发`执行的，具有`相同但独立的地址空间`，并`共享文件`

### 回收子进程

当一个子进程终止时，内核并不是立即将它清除，而是将进程保持在`已终止`的状态中，直到被它的父进程`回收`

如果一个父进程终止了，内核会安排`init进程`成为它的孤儿进程的养父，init进程的PID为`1`，是系统启动时内核创建的，它`不会终止`，是所有进程的`祖先`

### 加载并运行程序

execve函数在当前进程的上下文中加载并运行一个新程序

fork与execve的区别：

- 1.fork调用一次返回两次，execve调用一次但`不返回`

- 2.fork在新的子进程中运行与父进程相同的程序，子进程是父进程的一个`复制品`，而execve函数在`当前进程`的上下文中加载并运行新程序，它会`覆盖`当前进程的地址空间，但并`没有`创建一个新进程

## 信号

信号允许内核或进程`中断`其他进程

一个信号就是一条消息，它`通知进程`系统中发生了一个某种类型的事件

传送一个信号有两个步骤：发送信号和接收信号

### 发送信号

`内核`通过更新目的进程上下文中的`某个状态`，发送一个信号给目的进程

一个进程可以发送信号给它自己

发送一个信号可能有两种原因：

- 1.内核检测到一个`系统事件`，如零除错误或子进程终止

- 2.一个进程调用了`kill函数`

向进程发送信号的机制都是基于`进程组`这个概念的

#### 进程组

每个进程都只属于一个`进程组`，它由一个正整数`进程组ID`来标识

子进程默认与父进程同组，进程可以使用setpgid函数来改变自己或其它进程的进程组

如果kill函数的参数pid为0，则会向调用进程`所在进程组中的每个进程`（包括调用进程自己）发送信号

#### 作业 job

Unix shell使用`作业（job）`来表示对一条命令行求值而创建的进程，任何时刻至多只有一个前台作业和多个后台作业

命令：

```
ls | sort
```

会创建一个由`两个进程`组成的前台作业，它们通过Unix管道连接起来，一个进程运行ls程序，一个运行sort程序

shell为每个作业创建一个`独立的进程组`

在键盘上输入`Ctrl+c`会发送SIGINT信号到前台进程组的每个进程，这将终止前台作业


### 接收信号

目的进程被内核`强迫`以某种方式对信号的发送作出反应时，它就`接收`了这个信号

进程可以`忽略`这个信号，终止或者通过执行信号处理程序`捕获`这个信号

